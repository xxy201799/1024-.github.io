<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法_排序算法</title>
      <link href="/1024-xy.github.io/2020/03/07/suan-fa-pai-xu-suan-fa/"/>
      <url>/1024-xy.github.io/2020/03/07/suan-fa-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="八大排序算法"><a href="#八大排序算法" class="headerlink" title="八大排序算法"></a>八大排序算法</h1><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p><img src="https://upload-images.jianshu.io/upload_images/196518-49509183dfb68c64.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/400/format/webp" alt="冒泡排序">  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式_原型模式_建造者模式</title>
      <link href="/1024-xy.github.io/2020/03/07/she-ji-mo-shi-yuan-xing-mo-shi-jian-zao-zhe-mo-shi/"/>
      <url>/1024-xy.github.io/2020/03/07/she-ji-mo-shi-yuan-xing-mo-shi-jian-zao-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="原型模式与建造者模式"><a href="#原型模式与建造者模式" class="headerlink" title="原型模式与建造者模式"></a>原型模式与建造者模式</h1><h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><p>原型模式其主要目的是为了防止当我们想新建一个实体对象并为其赋值时，需要不停调用其get set方法为该对象赋值，而，原型模式是将对象赋值放在该对象内部，直接调用其克隆方法就能完成赋值。</p><h2 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h2><p>实现cloneable接口的属于浅克隆，它只能完成对对象基本数据类型的复制，但对于对象内的对象引用数据类型，只能复制其地址，而不能复制其内存中的值。</p><pre><code>public static void main(String[] args) throws CloneNotSupportedException {          Address address = new Address(&quot;CH&quot; , &quot;SD&quot; , &quot;QD&quot;);          Customer customer1 = new Customer(1 , 23 , address);          Customer customer2 = customer1.clone();          customer2.getAddress().setCity(&quot;JN&quot;);          customer2.setID(2);          System.out.println(&quot;customer1:&quot;+customer1.toString());          System.out.println(&quot;customer2:&quot;+customer2.toString());      }  }  class Customer implements Cloneable{      public int ID;      public int age;      public Address address;      public int getID() {          return ID;      }      public void setID(int iD) {          ID = iD;      }      public int getAge() {          return age;      }      public void setAge(int age) {          this.age = age;      }      public Address getAddress() {          return address;      }      public void setAddress(Address address) {          this.address = address;      }      public Customer(int iD, int age, Address address) {          super();          ID = iD;          this.age = age;          this.address = address;      }      @Override      public String toString() {          return &quot;Customer [ID=&quot; + ID + &quot;, age=&quot; + age + &quot;, address=&quot; + address                  + &quot;]&quot;;      }      @Override      public Customer clone() throws CloneNotSupportedException {          return (Customer) super.clone();      }  }  class Address{      private String country;      private String province;      private String city;      public String getCountry() {          return country;      }      public void setCountry(String country) {          this.country = country;      }      public String getProvince() {          return province;      }      public void setProvince(String province) {          this.province = province;      }      public String getCity() {          return city;      }      public void setCity(String city) {          this.city = city;      }      @Override      public String toString() {          return &quot;Address [country=&quot; + country + &quot;, province=&quot; + province                  + &quot;, city=&quot; + city + &quot;]&quot;;      }      public Address(String country, String province, String city) {          super();          this.country = country;          this.province = province;          this.city = city;      }  }  //输出的结果是：  //customer1:Customer [ID=1, age=23, address=Address [country=CH, province=SD, city=JN]]  //customer2:Customer [ID=2, age=23, address=Address [country=CH, province=SD, city=JN]]  </code></pre><h2 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h2><p>深克隆与浅克隆的区别就是，浅克隆不会克隆原对象中的引用类型，仅仅拷贝了引用类型的指向。深克隆则拷贝了所有。也就是说深克隆能够做到原对象和新对象之间完全没有影响。  </p><p>而深克隆的实现就是在引用类型所在的类实现Cloneable接口，并使用public访问修饰符重写clone方法。 </p><p>1．Address类实现Cloneable接口，重写clone方法;</p><pre><code>@Override  public Address clone() throws CloneNotSupportedException {      return (Address) super.clone();  }  </code></pre><p>2.在Customer类的clone方法中调用Address类的clone方法。</p><pre><code>@Override  public Customer clone() throws CloneNotSupportedException {      Customer customer = (Customer) super.clone();      customer.address = address.clone();      return customer;  }  输出结果customer1:Customer[ID=1, age=23, address=Address [country=CH, province=SD, city=QD]]customer2:Customer[ID=2, age=23, address=Address [country=CH, province=SD, city=JN]]</code></pre><p>发现customer2无论如何修改，customer1都没有受到影响。<br>实现深克隆的另一种方法就是使用序列化，将对象写入到流中，这样对象的内容就变成了字节流，也就不存在什么引用了。然后读取字节流反序列化为对象就完成了完全的复制操作了。  </p><pre><code> Address address = new Address(&quot;CH&quot; , &quot;SD&quot; , &quot;QD&quot;);   Customer customer1 = new Customer(1 , 23 , address);   Customer customer2 = (Customer) cloneObject(customer1);   customer2.getAddress().setCity(&quot;JN&quot;);   customer2.setID(2);   System.out.println(&quot;customer1:&quot;+customer1.toString());   System.out.println(&quot;customer2:&quot;+customer2.toString());  //customer1:Customer [ID=1, age=23, address=Address [country=CH, province=SD, city=QD]]  //customer2:Customer [ID=2, age=23, address=Address [country=CH, province=SD, city=JN]]</code></pre><p>cloneObject方法的定义：  </p><pre><code>public static Object cloneObject(Object obj) throws IOException, ClassNotFoundException{      ByteArrayOutputStream byteOut = new ByteArrayOutputStream();      ObjectOutputStream out = new ObjectOutputStream(byteOut);      out.writeObject(obj);       ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());      ObjectInputStream in =new ObjectInputStream(byteIn);      return in.readObject();  }    </code></pre><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>建造者模式使用多个对象一步一步构建成一个<strong>复杂的对象</strong>。这种类型的设计模式属于建造型模式，它提供了一种创建对象的最佳方式。<br>一个Builder会一步步构建最终对象。该Builder类是独立于其他对象。  </p><p>使用建造者模式构建sql</p><p>package com.xxy.gper.model.建造者模式;</p><pre><code>/** * sql排序组件 * @author Tom */public class Order {    private boolean ascending; //升序还是降序    private String propertyName; //哪个字段升序，哪个字段降序    public String toString() {        return propertyName + &#39; &#39; + (ascending ? &quot;asc&quot; : &quot;desc&quot;);    }    /**     * Constructor for Order.     */    protected Order(String propertyName, boolean ascending) {        this.propertyName = propertyName;        this.ascending = ascending;    }    /**     * Ascending order     *     * @param propertyName     * @return Order     */    public static Order asc(String propertyName) {        return new Order(propertyName, true);    }    /**     * Descending order     *     * @param propertyName     * @return Order     */    public static Order desc(String propertyName) {        return new Order(propertyName, false);    }}package com.xxy.gper.model.建造者模式;import java.io.Serializable;import java.util.ArrayList;import java.util.List;/** * QueryRule,主要功能用于构造查询条件 *  * @author Tom */public final class QueryRule implements Serializable{    private static final long serialVersionUID = 1L;    public static final int ASC_ORDER = 101;    public static final int DESC_ORDER = 102;    public static final int LIKE = 1;    public static final int IN = 2;    public static final int NOTIN = 3;    public static final int BETWEEN = 4;    public static final int EQ = 5;    public static final int NOTEQ = 6;    public static final int GT = 7;    public static final int GE = 8;    public static final int LT = 9;    public static final int LE = 10;    public static final int ISNULL = 11;    public static final int ISNOTNULL = 12;    public static final int ISEMPTY = 13;    public static final int ISNOTEMPTY = 14;    public static final int AND = 201;    public static final int OR = 202;    private List&lt;Rule&gt; ruleList = new ArrayList&lt;Rule&gt;();    private List&lt;QueryRule&gt; queryRuleList = new ArrayList&lt;QueryRule&gt;();    private String propertyName;    private QueryRule() {}    private QueryRule(String propertyName) {        this.propertyName = propertyName;    }    public static QueryRule getInstance() {        return new QueryRule();    }    /**     * 添加升序规则     * @param propertyName     * @return     */    public QueryRule addAscOrder(String propertyName) {        this.ruleList.add(new Rule(ASC_ORDER, propertyName));        return this;    }    /**     * 添加降序规则     * @param propertyName     * @return     */    public QueryRule addDescOrder(String propertyName) {        this.ruleList.add(new Rule(DESC_ORDER, propertyName));        return this;    }    public QueryRule andIsNull(String propertyName) {        this.ruleList.add(new Rule(ISNULL, propertyName).setAndOr(AND));        return this;    }    public QueryRule andIsNotNull(String propertyName) {        this.ruleList.add(new Rule(ISNOTNULL, propertyName).setAndOr(AND));        return this;    }    public QueryRule andIsEmpty(String propertyName) {        this.ruleList.add(new Rule(ISEMPTY, propertyName).setAndOr(AND));        return this;    }    public QueryRule andIsNotEmpty(String propertyName) {        this.ruleList.add(new Rule(ISNOTEMPTY, propertyName).setAndOr(AND));        return this;    }    public QueryRule andLike(String propertyName, Object value) {        this.ruleList.add(new Rule(LIKE, propertyName, new Object[] { value }).setAndOr(AND));        return this;    }    public QueryRule andEqual(String propertyName, Object value) {        this.ruleList.add(new Rule(EQ, propertyName, new Object[] { value }).setAndOr(AND));        return this;    }    public QueryRule andBetween(String propertyName, Object... values) {        this.ruleList.add(new Rule(BETWEEN, propertyName, values).setAndOr(AND));        return this;    }    public QueryRule andIn(String propertyName, List&lt;Object&gt; values) {        this.ruleList.add(new Rule(IN, propertyName, new Object[] { values }).setAndOr(AND));        return this;    }    public QueryRule andIn(String propertyName, Object... values) {        this.ruleList.add(new Rule(IN, propertyName, values).setAndOr(AND));        return this;    }    public QueryRule andNotIn(String propertyName, List&lt;Object&gt; values) {        this.ruleList.add(new Rule(NOTIN, propertyName, new Object[] { values }).setAndOr(AND));        return this;    }    public QueryRule orNotIn(String propertyName, Object... values) {        this.ruleList.add(new Rule(NOTIN, propertyName, values).setAndOr(OR));        return this;    }    public QueryRule andNotEqual(String propertyName, Object value) {        this.ruleList.add(new Rule(NOTEQ, propertyName, new Object[] { value }).setAndOr(AND));        return this;    }    public QueryRule andGreaterThan(String propertyName, Object value) {        this.ruleList.add(new Rule(GT, propertyName, new Object[] { value }).setAndOr(AND));        return this;    }    public QueryRule andGreaterEqual(String propertyName, Object value) {        this.ruleList.add(new Rule(GE, propertyName, new Object[] { value }).setAndOr(AND));        return this;    }    public QueryRule andLessThan(String propertyName, Object value) {        this.ruleList.add(new Rule(LT, propertyName, new Object[] { value }).setAndOr(AND));        return this;    }    public QueryRule andLessEqual(String propertyName, Object value) {        this.ruleList.add(new Rule(LE, propertyName, new Object[] { value }).setAndOr(AND));        return this;    }    public QueryRule orIsNull(String propertyName) {        this.ruleList.add(new Rule(ISNULL, propertyName).setAndOr(OR));        return this;    }    public QueryRule orIsNotNull(String propertyName) {        this.ruleList.add(new Rule(ISNOTNULL, propertyName).setAndOr(OR));        return this;    }    public QueryRule orIsEmpty(String propertyName) {        this.ruleList.add(new Rule(ISEMPTY, propertyName).setAndOr(OR));        return this;    }    public QueryRule orIsNotEmpty(String propertyName) {        this.ruleList.add(new Rule(ISNOTEMPTY, propertyName).setAndOr(OR));        return this;    }    public QueryRule orLike(String propertyName, Object value) {        this.ruleList.add(new Rule(LIKE, propertyName, new Object[] { value }).setAndOr(OR));        return this;    }    public QueryRule orEqual(String propertyName, Object value) {        this.ruleList.add(new Rule(EQ, propertyName, new Object[] { value }).setAndOr(OR));        return this;    }    public QueryRule orBetween(String propertyName, Object... values) {        this.ruleList.add(new Rule(BETWEEN, propertyName, values).setAndOr(OR));        return this;    }    public QueryRule orIn(String propertyName, List&lt;Object&gt; values) {        this.ruleList.add(new Rule(IN, propertyName, new Object[] { values }).setAndOr(OR));        return this;    }    public QueryRule orIn(String propertyName, Object... values) {        this.ruleList.add(new Rule(IN, propertyName, values).setAndOr(OR));        return this;    }    public QueryRule orNotEqual(String propertyName, Object value) {        this.ruleList.add(new Rule(NOTEQ, propertyName, new Object[] { value }).setAndOr(OR));        return this;    }    public QueryRule orGreaterThan(String propertyName, Object value) {        this.ruleList.add(new Rule(GT, propertyName, new Object[] { value }).setAndOr(OR));        return this;    }    public QueryRule orGreaterEqual(String propertyName, Object value) {        this.ruleList.add(new Rule(GE, propertyName, new Object[] { value }).setAndOr(OR));        return this;    }    public QueryRule orLessThan(String propertyName, Object value) {        this.ruleList.add(new Rule(LT, propertyName, new Object[] { value }).setAndOr(OR));        return this;    }    public QueryRule orLessEqual(String propertyName, Object value) {        this.ruleList.add(new Rule(LE, propertyName, new Object[] { value }).setAndOr(OR));        return this;    }    public List&lt;Rule&gt; getRuleList() {        return this.ruleList;    }    public List&lt;QueryRule&gt; getQueryRuleList() {        return this.queryRuleList;    }    public String getPropertyName() {        return this.propertyName;    }    protected class Rule implements Serializable {        private static final long serialVersionUID = 1L;        private int type;    //规则的类型        private String property_name;        private Object[] values;        private int andOr = AND;        public Rule(int paramInt, String paramString) {            this.property_name = paramString;            this.type = paramInt;        }        public Rule(int paramInt, String paramString,                Object[] paramArrayOfObject) {            this.property_name = paramString;            this.values = paramArrayOfObject;            this.type = paramInt;        }        public Rule setAndOr(int andOr){            this.andOr = andOr;            return this;        }        public int getAndOr(){            return this.andOr;        }        public Object[] getValues() {            return this.values;        }        public int getType() {            return this.type;        }        public String getPropertyName() {            return this.property_name;        }    }}package com.xxy.gper.model.建造者模式;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;import org.apache.commons.lang.ArrayUtils;import org.apache.commons.lang.StringUtils;/** * 根据QueryRule自动构建sql语句 * @author Tom * */public class QueryRuleSqlBuilder {    private int CURR_INDEX = 0; //记录参数所在的位置    private List&lt;String&gt; properties; //保存列名列表    private List&lt;Object&gt; values; //保存参数值列表    private List&lt;Order&gt; orders; //保存排序规则列表    private String whereSql = &quot;&quot;;     private String orderSql = &quot;&quot;;    private Object [] valueArr = new Object[]{};    private Map&lt;Object,Object&gt; valueMap = new HashMap&lt;Object,Object&gt;();    /**     * 或得查询条件     * @return     */    private String getWhereSql(){        return this.whereSql;    }    /**     * 获得排序条件     * @return     */    private String getOrderSql(){        return this.orderSql;    }    /**     * 获得参数值列表     * @return     */    public Object [] getValues(){        return this.valueArr;    }    /**     * 获取参数列表     * @return     */    private Map&lt;Object,Object&gt; getValueMap(){        return this.valueMap;    }    /**     * 创建SQL构造器     * @param queryRule     */    public QueryRuleSqlBuilder(QueryRule queryRule) {        CURR_INDEX = 0;        properties = new ArrayList&lt;String&gt;();        values = new ArrayList&lt;Object&gt;();        orders = new ArrayList&lt;Order&gt;();        for (QueryRule.Rule rule : queryRule.getRuleList()) {            switch (rule.getType()) {            case QueryRule.BETWEEN:                processBetween(rule);                break;            case QueryRule.EQ:                processEqual(rule);                break;            case QueryRule.LIKE:                processLike(rule);                break;            case QueryRule.NOTEQ:                processNotEqual(rule);                break;            case QueryRule.GT:                processGreaterThen(rule);                break;            case QueryRule.GE:                processGreaterEqual(rule);                break;            case QueryRule.LT:                processLessThen(rule);                break;            case QueryRule.LE:                processLessEqual(rule);                break;            case QueryRule.IN:                processIN(rule);                break;            case QueryRule.NOTIN:                processNotIN(rule);                break;            case QueryRule.ISNULL:                processIsNull(rule);                break;            case QueryRule.ISNOTNULL:                processIsNotNull(rule);                break;            case QueryRule.ISEMPTY:                processIsEmpty(rule);                break;            case QueryRule.ISNOTEMPTY:                processIsNotEmpty(rule);                break;            case QueryRule.ASC_ORDER:                processOrder(rule);                break;            case QueryRule.DESC_ORDER:                processOrder(rule);                break;            default:                throw new IllegalArgumentException(&quot;type &quot; + rule.getType() + &quot; not supported.&quot;);            }        }        //拼装where语句        appendWhereSql();        //拼装排序语句        appendOrderSql();        //拼装参数值        appendValues();    }    /**     * 去掉order     *      * @param sql     * @return     */    private String removeOrders(String sql) {        Pattern p = Pattern.compile(&quot;order\\s*by[\\w|\\W|\\s|\\S]*&quot;, Pattern.CASE_INSENSITIVE);        Matcher m = p.matcher(sql);        StringBuffer sb = new StringBuffer();        while (m.find()) {            m.appendReplacement(sb, &quot;&quot;);        }        m.appendTail(sb);        return sb.toString();    }    /**     * 去掉select     *      * @param sql     * @return     */    private String removeSelect(String sql) {        if(sql.toLowerCase().matches(&quot;from\\s+&quot;)){            int beginPos = sql.toLowerCase().indexOf(&quot;from&quot;);            return sql.substring(beginPos);        }else{            return sql;        }    }    /**     * 处理like     * @param rule     */    private  void processLike(QueryRule.Rule rule) {        if (ArrayUtils.isEmpty(rule.getValues())) {            return;        }        Object obj = rule.getValues()[0];        if (obj != null) {            String value = obj.toString();            if (!StringUtils.isEmpty(value)) {                value = value.replace(&#39;*&#39;, &#39;%&#39;);                obj = value;            }        }        add(rule.getAndOr(),rule.getPropertyName(),&quot;like&quot;,&quot;%&quot;+rule.getValues()[0]+&quot;%&quot;);    }    /**     * 处理between     * @param rule     */    private  void processBetween(QueryRule.Rule rule) {        if ((ArrayUtils.isEmpty(rule.getValues()))                || (rule.getValues().length &lt; 2)) {            return;        }        add(rule.getAndOr(),rule.getPropertyName(),&quot;&quot;,&quot;between&quot;,rule.getValues()[0],&quot;and&quot;);        add(0,&quot;&quot;,&quot;&quot;,&quot;&quot;,rule.getValues()[1],&quot;&quot;);    }    /**     * 处理 =     * @param rule     */    private  void processEqual(QueryRule.Rule rule) {        if (ArrayUtils.isEmpty(rule.getValues())) {            return;        }        add(rule.getAndOr(),rule.getPropertyName(),&quot;=&quot;,rule.getValues()[0]);    }    /**     * 处理 &lt;&gt;     * @param rule     */    private  void processNotEqual(QueryRule.Rule rule) {        if (ArrayUtils.isEmpty(rule.getValues())) {            return;        }        add(rule.getAndOr(),rule.getPropertyName(),&quot;&lt;&gt;&quot;,rule.getValues()[0]);    }    /**     * 处理 &gt;     * @param rule     */    private  void processGreaterThen(            QueryRule.Rule rule) {        if (ArrayUtils.isEmpty(rule.getValues())) {            return;        }        add(rule.getAndOr(),rule.getPropertyName(),&quot;&gt;&quot;,rule.getValues()[0]);    }    /**     * 处理&gt;=     * @param rule     */    private  void processGreaterEqual(            QueryRule.Rule rule) {        if (ArrayUtils.isEmpty(rule.getValues())) {            return;        }        add(rule.getAndOr(),rule.getPropertyName(),&quot;&gt;=&quot;,rule.getValues()[0]);    }    /**     * 处理&lt;     * @param rule     */    private  void processLessThen(QueryRule.Rule rule) {        if (ArrayUtils.isEmpty(rule.getValues())) {            return;        }        add(rule.getAndOr(),rule.getPropertyName(),&quot;&lt;&quot;,rule.getValues()[0]);    }    /**     * 处理&lt;=     * @param rule     */    private  void processLessEqual(            QueryRule.Rule rule) {        if (ArrayUtils.isEmpty(rule.getValues())) {            return;        }        add(rule.getAndOr(),rule.getPropertyName(),&quot;&lt;=&quot;,rule.getValues()[0]);    }    /**     * 处理  is null     * @param rule     */    private  void processIsNull(QueryRule.Rule rule) {        add(rule.getAndOr(),rule.getPropertyName(),&quot;is null&quot;,null);    }    /**     * 处理 is not null     * @param rule     */    private  void processIsNotNull(QueryRule.Rule rule) {        add(rule.getAndOr(),rule.getPropertyName(),&quot;is not null&quot;,null);    }    /**     * 处理  &lt;&gt;&#39;&#39;     * @param rule     */    private  void processIsNotEmpty(QueryRule.Rule rule) {        add(rule.getAndOr(),rule.getPropertyName(),&quot;&lt;&gt;&quot;,&quot;&#39;&#39;&quot;);    }    /**     * 处理 =&#39;&#39;     * @param rule     */    private  void processIsEmpty(QueryRule.Rule rule) {        add(rule.getAndOr(),rule.getPropertyName(),&quot;=&quot;,&quot;&#39;&#39;&quot;);    }    /**     * 处理in和not in     * @param rule     * @param name     */    private void inAndNotIn(QueryRule.Rule rule,String name){        if (ArrayUtils.isEmpty(rule.getValues())) {            return;        }        if ((rule.getValues().length == 1) &amp;&amp; (rule.getValues()[0] != null)                &amp;&amp; (rule.getValues()[0] instanceof List)) {            List&lt;Object&gt; list = (List) rule.getValues()[0];            if ((list != null) &amp;&amp; (list.size() &gt; 0)){                for (int i = 0; i &lt; list.size(); i++) {                    if(i == 0 &amp;&amp; i == list.size() - 1){                        add(rule.getAndOr(),rule.getPropertyName(),&quot;&quot;,name + &quot; (&quot;,list.get(i),&quot;)&quot;);                    }else if(i == 0 &amp;&amp; i &lt; list.size() - 1){                        add(rule.getAndOr(),rule.getPropertyName(),&quot;&quot;,name + &quot; (&quot;,list.get(i),&quot;&quot;);                    }                    if(i &gt; 0 &amp;&amp; i &lt; list.size() - 1){                        add(0,&quot;&quot;,&quot;,&quot;,&quot;&quot;,list.get(i),&quot;&quot;);                    }                    if(i == list.size() - 1 &amp;&amp; i != 0){                        add(0,&quot;&quot;,&quot;,&quot;,&quot;&quot;,list.get(i),&quot;)&quot;);                    }                }            }        } else {            Object[] list =  rule.getValues();            for (int i = 0; i &lt; list.length; i++) {                if(i == 0 &amp;&amp; i == list.length - 1){                    add(rule.getAndOr(),rule.getPropertyName(),&quot;&quot;,name + &quot; (&quot;,list[i],&quot;)&quot;);                }else if(i == 0 &amp;&amp; i &lt; list.length - 1){                    add(rule.getAndOr(),rule.getPropertyName(),&quot;&quot;,name + &quot; (&quot;,list[i],&quot;&quot;);                }                if(i &gt; 0 &amp;&amp; i &lt; list.length - 1){                    add(0,&quot;&quot;,&quot;,&quot;,&quot;&quot;,list[i],&quot;&quot;);                }                if(i == list.length - 1 &amp;&amp; i != 0){                    add(0,&quot;&quot;,&quot;,&quot;,&quot;&quot;,list[i],&quot;)&quot;);                }            }        }    }    /**     * 处理 not in     * @param rule     */    private void processNotIN(QueryRule.Rule rule){        inAndNotIn(rule,&quot;not in&quot;);    }    /**     * 处理 in     * @param rule     */    private  void processIN(QueryRule.Rule rule) {        inAndNotIn(rule,&quot;in&quot;);    }    /**     * 处理 order by     * @param rule 查询规则     */    private void processOrder(QueryRule.Rule rule) {        switch (rule.getType()) {        case QueryRule.ASC_ORDER:            // propertyName非空            if (!StringUtils.isEmpty(rule.getPropertyName())) {                orders.add(Order.asc(rule.getPropertyName()));            }            break;        case QueryRule.DESC_ORDER:            // propertyName非空            if (!StringUtils.isEmpty(rule.getPropertyName())) {                orders.add(Order.desc(rule.getPropertyName()));            }            break;        default:            break;        }    }    /**     * 加入到sql查询规则队列     * @param andOr and 或者 or     * @param key 列名     * @param split 列名与值之间的间隔     * @param value 值     */    private  void add(int andOr,String key,String split ,Object value){        add(andOr,key,split,&quot;&quot;,value,&quot;&quot;);    }    /**     * 加入到sql查询规则队列     * @param andOr and 或则 or     * @param key 列名     * @param split 列名与值之间的间隔     * @param prefix 值前缀     * @param value 值     * @param suffix 值后缀     */    private  void add(int andOr,String key,String split ,String prefix,Object value,String  suffix){        String andOrStr = (0 == andOr ? &quot;&quot; :(QueryRule.AND == andOr ? &quot; and &quot; : &quot; or &quot;));          properties.add(CURR_INDEX, andOrStr + key + &quot; &quot; + split + prefix + (null != value ? &quot; ? &quot; : &quot; &quot;) + suffix);        if(null != value){            values.add(CURR_INDEX,value);            CURR_INDEX ++;        }    }    /**     * 拼装 where 语句     */    private void appendWhereSql(){        StringBuffer whereSql = new StringBuffer();        for (String p : properties) {            whereSql.append(p);        }        this.whereSql = removeSelect(removeOrders(whereSql.toString()));    }    /**     * 拼装排序语句     */    private void appendOrderSql(){        StringBuffer orderSql = new StringBuffer();        for (int i = 0 ; i &lt; orders.size(); i ++) {            if(i &gt; 0 &amp;&amp; i &lt; orders.size()){                orderSql.append(&quot;,&quot;);            }            orderSql.append(orders.get(i).toString());        }        this.orderSql = removeSelect(removeOrders(orderSql.toString()));    }    /**     * 拼装参数值     */    private void appendValues(){        Object [] val = new Object[values.size()];        for (int i = 0; i &lt; values.size(); i ++) {            val[i] = values.get(i);            valueMap.put(i, values.get(i));        }        this.valueArr = val;    }    public String builder(String tableName){        String ws = removeFirstAnd(this.getWhereSql());        String whereSql = (&quot;&quot;.equals(ws) ? ws : (&quot; where &quot; + ws));        String sql = &quot;select * from &quot; + tableName + whereSql;        Object [] values = this.getValues();        String orderSql = this.getOrderSql();        orderSql = (StringUtils.isEmpty(orderSql) ? &quot; &quot; : (&quot; order by &quot; + orderSql));        sql += orderSql;        return sql;    }    private String removeFirstAnd(String sql){        if(StringUtils.isEmpty(sql)){return sql;}        return sql.trim().toLowerCase().replaceAll(&quot;^\\s*and&quot;, &quot;&quot;) + &quot; &quot;;    }}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式_门面模式_装饰模式</title>
      <link href="/1024-xy.github.io/2020/03/04/she-ji-mo-shi-men-mian-mo-shi-zhuang-shi-mo-shi/"/>
      <url>/1024-xy.github.io/2020/03/04/she-ji-mo-shi-men-mian-mo-shi-zhuang-shi-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="门面模式与装饰器模式"><a href="#门面模式与装饰器模式" class="headerlink" title="门面模式与装饰器模式"></a>门面模式与装饰器模式</h1><h2 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h2><p>门面模式又叫外观模式，提供了一个统一的接口，用来访问子系统的一群接口。</p><p>特征：门面模式定义了一个高层接口，让子系统更容易使用。属于结构模式  </p><h3 id="门面模式适用场景"><a href="#门面模式适用场景" class="headerlink" title="门面模式适用场景"></a>门面模式适用场景</h3><p>越来越复杂的子系统，需要一个统一的接口，供用户使用。 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式_工厂模式</title>
      <link href="/1024-xy.github.io/2020/03/03/she-ji-mo-shi-gong-han-mo-shi/"/>
      <url>/1024-xy.github.io/2020/03/03/she-ji-mo-shi-gong-han-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式总览，工厂模式"><a href="#设计模式总览，工厂模式" class="headerlink" title="设计模式总览，工厂模式"></a>设计模式总览，工厂模式</h1><h2 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h2><ul><li>开闭原则<ul><li>对扩展开放，对修改关闭</li></ul></li><li>单一职责原则<ul><li>一个类，一个方法，一个接口，只干一件事</li></ul></li><li>依赖倒置原则<ul><li>通过抽象，实现各个类之间，各个模块之间相互不影响</li></ul></li><li>接口隔离原则<ul><li>接口非常单一，只做某一类事情</li></ul></li><li>迪米特法则<ul><li>对于一个类，知道的越少越好</li></ul></li><li>里式替换原则<ul><li>子类可以扩展父类的功能，但是不能修改父类原有的功能</li></ul></li><li>合成复用原则<ul><li>尽量使用对象组合，聚合，而不是继承。</li></ul></li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><ol><li>在编码不能预见需要创建哪种类的实例</li><li>系统不应依赖于产品类实例如何被创建，组合和表达的细节</li></ol><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><blockquote><p> <strong>工厂类角色</strong>：这是本模式的核心，含有一定的商业逻辑和判断逻辑，根据逻辑的不同，产生具体的工厂产品，例如例子中的Driver类<br> <strong>抽象产品角色</strong>：它一般是具体产品继承父类或者实现的接口。由接口或者抽象类来实现。<br> <strong>具体角色产品</strong>：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现，如例子中的Benz、Bmw类。</p></blockquote><pre><code>//抽象产品  abstract class Car{      private String name;      public abstract void drive();      public String getName() {          return name;      }      public void setName(String name) {          this.name = name;      }  }  //具体产品  class Benz extends Car{      public void drive(){          System.out.println(this.getName()+&quot;----go-----------------------&quot;);      }  }  class Bmw extends Car{      public void drive(){          System.out.println(this.getName()+&quot;----go-----------------------&quot;);      }  }  //简单工厂  class Driver{      public static Car createCar(String car){          Car c = null;          if(&quot;Benz&quot;.equalsIgnoreCase(car))              c = new Benz();          else if(&quot;Bmw&quot;.equalsIgnoreCase(car))              c = new Bmw();          return c;      }  }  //main方法  public class BossSimplyFactory {      public static void main(String[] args) throws IOException {          Car car = Driver.createCar(&quot;benz&quot;);          car.setName(&quot;benz&quot;);          car.drive();      }  </code></pre><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><blockquote><p><strong>抽象工厂角色</strong>：这是工厂方法模式的核心，它与应用程序无关，是具体工厂角色必须实现的接口或者必须继承的父类。<br><strong>具体工厂角色</strong>：它含有和具体业务逻辑有关的代码。<br><strong>抽象产品角色</strong>：它是具体产品继承的父类或者是实现的接口。<br><strong>具体产品角色</strong>：具体工厂角色所创建的对象就是此角色的实例。</p></blockquote><pre><code>//抽象产品  abstract class Car{      private String name;      public abstract void drive();      public String getName() {          return name;      }      public void setName(String name) {          this.name = name;      }  }  //具体产品  class Benz extends Car{      public void drive(){          System.out.println(this.getName()+&quot;----go-----------------------&quot;);      }  }  class Bmw extends Car{      public void drive(){          System.out.println(this.getName()+&quot;----go-----------------------&quot;);      }  }  //抽象工厂  abstract class Driver{      public abstract Car createCar(String car) throws Exception;  }  //具体工厂（每个具体工厂负责一个具体产品）  class BenzDriver extends Driver{      public Car createCar(String car) throws Exception {          return new Benz();      }  }  class BmwDriver extends Driver{      public Car createCar(String car) throws Exception {          return new Bmw();      }  }  public class Boss{     public static void main(String[] args) throws Exception {          Driver d = new BenzDriver();          Car c = d.createCar(&quot;benz&quot;);           c.setName(&quot;benz&quot;);          c.drive();      }  }  </code></pre><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><blockquote><p><strong>抽象工厂角色</strong>: 这是工厂方法的核心，它与应用程序无关。<br><strong>具体工厂角色</strong>：它含有具有业务逻辑有关的代码。<br><strong>抽象产品角色</strong>：它是具体产品继承的父类或者是实现的接口。<br><strong>具体产品角色</strong>：具体工厂角色所创建的对象就是角色的实例。</p></blockquote><pre><code>//抽象产品（Bmw和Audi同理）  abstract class BenzCar{      private String name;      public abstract void drive();      public String getName() {          return name;      }      public void setName(String name) {          this.name = name;      }  }  //具体产品（Bmw和Audi同理）  class BenzSportCar extends BenzCar{      public void drive(){          System.out.println(this.getName()+&quot;----BenzSportCar-----------------------&quot;);      }  }  class BenzBusinessCar extends BenzCar{      public void drive(){          System.out.println(this.getName()+&quot;----BenzBusinessCar-----------------------&quot;);      }  }  abstract class BmwCar{      private String name;      public abstract void drive();      public String getName() {          return name;      }      public void setName(String name) {          this.name = name;      }  }  class BmwSportCar extends BmwCar{      public void drive(){          System.out.println(this.getName()+&quot;----BmwSportCar-----------------------&quot;);      }  }  class BmwBusinessCar extends BmwCar{      public void drive(){          System.out.println(this.getName()+&quot;----BmwBusinessCar-----------------------&quot;);      }  }  abstract class AudiCar{      private String name;      public abstract void drive();      public String getName() {          return name;      }      public void setName(String name) {          this.name = name;      }  }  class AudiSportCar extends AudiCar{      public void drive(){          System.out.println(this.getName()+&quot;----AudiSportCar-----------------------&quot;);      }  }  class AudiBusinessCar extends AudiCar{      public void drive(){          System.out.println(this.getName()+&quot;----AudiBusinessCar-----------------------&quot;);      }  }  //抽象工厂  abstract class Driver3{      public abstract BenzCar createBenzCar(String car) throws Exception;      public abstract BmwCar createBmwCar(String car) throws Exception;      public abstract AudiCar createAudiCar(String car) throws Exception;  }  //具体工厂  class SportDriver extends Driver3{      public BenzCar createBenzCar(String car) throws Exception {          return new BenzSportCar();      }      public BmwCar createBmwCar(String car) throws Exception {          return new BmwSportCar();      }      public AudiCar createAudiCar(String car) throws Exception {          return new AudiSportCar();      }  }  class BusinessDriver extends Driv    er3{      public BenzCar createBenzCar(String car) throws Exception {          return new BenzBusinessCar();      }      public BmwCar createBmwCar(String car) throws Exception {          return new BmwBusinessCar();      }      public AudiCar createAudiCar(String car) throws Exception {          return new AudiBusinessCar();      }  }  public class BossAbstractFactory {      public static void main(String[] args) throws Exception {            Driver3 d = new BusinessDriver();          AudiCar car = d.createAudiCar(&quot;&quot;);          car.drive();      }  }  </code></pre><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例有七种写法，推荐使用枚举单例模式</p><pre><code>public enum Singleton {       INSTANCE;       public void doSomeThing() {       }   }  </code></pre><p>当我们一个类并不是单例写法，我们想要获得单例也可以用枚举实现</p><pre><code>class Resource{}public enum SomeThing {    INSTANCE;    private Resource instance;    SomeThing() {        instance = new Resource();    }    public Resource getInstance() {        return instance;    }} </code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>问题详记</title>
      <link href="/1024-xy.github.io/2019/12/27/wen-ti-xiang-ji/"/>
      <url>/1024-xy.github.io/2019/12/27/wen-ti-xiang-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="问题详记"><a href="#问题详记" class="headerlink" title="问题详记"></a>问题详记</h1><h2 id="nacos整合gageway产生的问题"><a href="#nacos整合gageway产生的问题" class="headerlink" title="nacos整合gageway产生的问题"></a>nacos整合gageway产生的问题</h2><p>spring cloud alibaba整合nacos与gateway，发现服务路由一直不行，报错invalid host，开始以为是云服务器无法穿透本地主机，结果本地安装nacos同样不行，将user微服务名称从vue_blog_user改为user-center结果可行<br>原因：ribbon不支持下划线，所以通过uri.gethost获取不到带有下划线的名称。究其原因，java.net.URI不理解域名下划线。  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ常见面试题详解</title>
      <link href="/1024-xy.github.io/2019/11/23/rabbitmq-chang-jian-mian-shi-ti-xiang-jie/"/>
      <url>/1024-xy.github.io/2019/11/23/rabbitmq-chang-jian-mian-shi-ti-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="rabbitMQ消息队列"><a href="#rabbitMQ消息队列" class="headerlink" title="rabbitMQ消息队列"></a>rabbitMQ消息队列</h1><h2 id="RabbitMQ消息队列的优势"><a href="#RabbitMQ消息队列的优势" class="headerlink" title="RabbitMQ消息队列的优势"></a>RabbitMQ消息队列的优势</h2><ol><li>解耦：服务之间或应用程序之间的调用实现解耦</li><li>异步：生产者将消息写入队列，不用管消费者收没收到，而消费者只需要订阅，等拿到消息了在进行逻辑处理。</li><li>削峰：并发量大的时候，所有请求直接怼数据库，造成数据库连接异常。</li></ol><h2 id="rabbit中的交换器"><a href="#rabbit中的交换器" class="headerlink" title="rabbit中的交换器"></a>rabbit中的交换器</h2><ol><li>direct: 默认的交换器，必须要配置，该路由器非常简单，如果路由键匹配，消息就被投递到相应的队列。</li><li>fanout: 这种类型的交换器将收到的消息广播到绑定的队列上。消息通信模式很简单：当你发送一条消息到fanout交换器时，它会把消息投递到所有绑定它的消息队列。</li><li>topic:它能使得不同源头的消息能够到达同一队列，其基于通配符进行匹配。</li></ol><h2 id="RabbitMQ的broker是指什么？cluster又是什么？"><a href="#RabbitMQ的broker是指什么？cluster又是什么？" class="headerlink" title="RabbitMQ的broker是指什么？cluster又是什么？"></a>RabbitMQ的broker是指什么？cluster又是什么？</h2><p>broker 是指一个或多个 erlang node 的逻辑分组，且 node 上运行着 RabbitMQ 应用程序。cluster 是在 broker 的基础之上，增加了 node 之间共享元数据的约束。</p><h2 id="RabbitMQ概念里的channel、exchange和queue是逻辑概念，还是对应着进程实体？分别起什么作用？"><a href="#RabbitMQ概念里的channel、exchange和queue是逻辑概念，还是对应着进程实体？分别起什么作用？" class="headerlink" title="RabbitMQ概念里的channel、exchange和queue是逻辑概念，还是对应着进程实体？分别起什么作用？"></a>RabbitMQ概念里的channel、exchange和queue是逻辑概念，还是对应着进程实体？分别起什么作用？</h2><ol><li>channel:是实际进行路由工作的实体，它负责按照routing_key将message投递给queue</li><li>queue:单独进程运行的消息队列，消息存在该队列里。</li><li>exchange:交换机，内部实现为保存binding(队列绑定）关系的查找表。</li></ol><p>channel是真实TCP连接上的虚拟连接，每个channel对应一个线程，一个线程可以处理多个channel。绑定到channel上的message是有序的。</p><h2 id="vhost是指什么？起什么作用？"><a href="#vhost是指什么？起什么作用？" class="headerlink" title="vhost是指什么？起什么作用？"></a>vhost是指什么？起什么作用？</h2><p>vhost是虚拟主机的意思。它像一个小型的rabbitmq，拥有自己的队列、交换器和绑定，更重要的是它拥有自己的权限机制。<br>作用：安全的使用一个rabbitmq服务众多应用程序，而不用担心你的两个完全没有产生联系的应用，因为使用了同一条队列产生错误的数据。它通过在各个实例间提供逻辑上的分离，允许你为不同的应用程序安全保密的运行数据。它既可以区分rabbitmq众多客户，又能避免队列名以及交换机的冲突。你只需要安装一台服务器，按需求启动或关闭vhost。</p><h2 id="消息基于什么传输？"><a href="#消息基于什么传输？" class="headerlink" title="消息基于什么传输？"></a>消息基于什么传输？</h2><p>rabbitmq基于信道的方式来传输数据。信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。</p><h2 id="消息如何分发？"><a href="#消息如何分发？" class="headerlink" title="消息如何分发？"></a>消息如何分发？</h2><p>若该队列至少有一个消费者订阅，消费将以循环的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。</p><h2 id="消息如何路由？？"><a href="#消息如何路由？？" class="headerlink" title="消息如何路由？？"></a>消息如何路由？？</h2><p>从概念上来说，消息路由必须有三部分：交换器、路由、绑定。生产者把消息发布到交换器上；绑定决定了消息如何从路由器到路由到特定的队列，并被消费者接收。  </p><ol><li>消息发布到交换器，消息将拥有一个路由键，在消息创建时设定。  </li><li>通过队列路由键，可以把队列绑定到交换器上。  </li><li>消息到达交换器，RabbitMQ会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）。如果能够匹配到队列，则消息会投递到相应队列中；如果不能匹配到任何队列，消息将进入“黑洞”。</li></ol><h2 id="什么是元数据？元数据分为哪些类型？包括哪些内容？与-cluster-相关的元数据有哪些？元数据是如何保存的？元数据在-cluster-中是如何分布的？"><a href="#什么是元数据？元数据分为哪些类型？包括哪些内容？与-cluster-相关的元数据有哪些？元数据是如何保存的？元数据在-cluster-中是如何分布的？" class="headerlink" title="什么是元数据？元数据分为哪些类型？包括哪些内容？与 cluster 相关的元数据有哪些？元数据是如何保存的？元数据在 cluster 中是如何分布的？"></a>什么是元数据？元数据分为哪些类型？包括哪些内容？与 cluster 相关的元数据有哪些？元数据是如何保存的？元数据在 cluster 中是如何分布的？</h2><p>在非 cluster 模式下，元数据主要分为 Queue 元数据（queue 名字和属性等）、Exchange 元数据（exchange 名字、类型和属性等）、Binding 元数据（存放路由关系的查找表）、Vhost 元数据（vhost 范围内针对前三者的名字空间约束和安全属性设置）。在 cluster 模式下，还包括 cluster 中 node 位置信息和 node 关系信息。元数据按照 erlang node 的类型确定是仅保存于 RAM 中，还是同时保存在 RAM 和 disk 上。元数据在 cluster 中是全 node 分布的。<br>下图所示为 queue 的元数据在单 node 和 cluster 两种模式下的分布图。<br><img src="https://img-blog.csdnimg.cn/20190410145539885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2plcnJ5RHphbg==,size_16,color_FFFFFF,t_70" alt="rabbitmq元数据"></p><h2 id="在单-node-系统和多-node-构成的-cluster-系统中声明-queue、exchange-，以及进行-binding-会有什么不同？"><a href="#在单-node-系统和多-node-构成的-cluster-系统中声明-queue、exchange-，以及进行-binding-会有什么不同？" class="headerlink" title="在单 node 系统和多 node 构成的 cluster 系统中声明 queue、exchange ，以及进行 binding 会有什么不同？"></a>在单 node 系统和多 node 构成的 cluster 系统中声明 queue、exchange ，以及进行 binding 会有什么不同？</h2><p>当你在单 node 上声明 queue 时，只要该 node 上相关元数据进行了变更，你就会得到 Queue.Declare-ok 回应；而在 cluster 上声明 queue ，则要求 cluster 上的全部node 都要进行元数据成功更新，才会得到 Queue.Declare-ok 回应。另外，若 node 类型为 RAM node 则变更的数据仅保存在内存中，若类型为 disk node 则还要变更保存在磁盘上的数据。</p><h2 id="如何确保消息正确地发送至RabbitMQ？"><a href="#如何确保消息正确地发送至RabbitMQ？" class="headerlink" title="如何确保消息正确地发送至RabbitMQ？"></a>如何确保消息正确地发送至RabbitMQ？</h2><p>RabbitMQ使用发送方确认模式，确保消息正确地发送到RabbitMQ。  </p><ul><li>消息落库，对消息状态进行打标：将消息持久化到数据库，设置状态，为发送中，已发送，未发送，发送失败等等状态，收到响应，根据响应状态设置消息状态。对一直未响应的消息做轮询，尝试发送，直到达到一定轮询次数，更改消息发送状态为失败。</li><li>发送方确认模式：将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一ID）。如果RabbitMQ发生内部错误从而导致消息丢失，会发送一条nack（not acknowledged，未确认）消息。发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</li></ul><h2 id="如何确保消息接收方消费了消息？"><a href="#如何确保消息接收方消费了消息？" class="headerlink" title="如何确保消息接收方消费了消息？"></a>如何确保消息接收方消费了消息？</h2><p>接收方消息确认机制：消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。这里并没有用到超时机制，RabbitMQ仅通过Consumer的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ给了Consumer足够长的时间来处理消息。</p><p>下面罗列几种特殊情况：</p><ul><li>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要根据bizId去重）  </li><li>如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息。</li></ul><h2 id="如何避免消息重复投递或重复消费？"><a href="#如何避免消息重复投递或重复消费？" class="headerlink" title="如何避免消息重复投递或重复消费？"></a>如何避免消息重复投递或重复消费？</h2><p>在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列；在消息消费时，要求消息体中必须要有一个bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重和幂等的依据，避免同一条消息被重复消费。  </p><p>这个问题针对业务场景来答分以下几点：  </p><ol><li><p>比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。  </p></li><li><p>再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。  </p><ol><li>如果消息需要落库，如何保证数据库与缓存的一致性</li><li>如果不落库，如何设置定时同步策略</li></ol></li><li><p>如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;id,message&gt;以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。  </p></li></ol><h2 id="如何解决丢数据的问题"><a href="#如何解决丢数据的问题" class="headerlink" title="如何解决丢数据的问题?"></a>如何解决丢数据的问题?</h2><ol><li>生产者丢数据</li></ol><p>生产者的消息没有投递到MQ中怎么办？从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。</p><p>transaction机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。</p><p>然而缺点就是吞吐量下降了。因此，按照博主的经验，生产上用confirm模式的居多。一旦channel进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个Ack给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了.如果rabiitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。</p><ol start="2"><li>消息队列丢数据</li></ol><p>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。</p><p>那么如何持久化呢，这里顺便说一下吧，其实也很容易，就下面两步</p><p>①、将queue的持久化标识durable设置为true,则代表是一个持久的队列</p><p>②、发送消息的时候将deliveryMode=2</p><p>这样设置以后，rabbitMQ就算挂了，重启后也能恢复数据。在消息还没有持久化到硬盘时，可能服务已经死掉，这种情况可以通过引入mirrored-queue即镜像队列，但也不能保证消息百分百不丢失（整个集群都挂掉）</p><ol start="3"><li>消费者丢数据</li></ol><p>启用手动确认模式可以解决这个问题</p><p>①自动确认模式，消费者挂掉，待ack的消息回归到队列中。消费者抛出异常，消息会不断的被重发，直到处理成功。不会丢失消息，即便服务挂掉，没有处理完成的消息会重回队列，但是异常会让消息不断重试。</p><p>②手动确认模式，如果消费者来不及处理就死掉时，没有响应ack时会重复发送一条信息给其他消费者；如果监听程序处理异常了，且未对异常进行捕获，会一直重复接收消息，然后一直抛异常；如果对异常进行了捕获，但是没有在finally里ack，也会一直重复发送消息(重试机制)。</p><p>③不确认模式，acknowledge=”none” 不使用确认机制，只要消息发送完成会立即在队列移除，无论客户端异常还是断开，只要发送完就移除，不会重发。</p><h2 id="死信队列和延迟队列的使用"><a href="#死信队列和延迟队列的使用" class="headerlink" title="死信队列和延迟队列的使用"></a>死信队列和延迟队列的使用</h2><p>死信队列也是一个正常的Exchange，和一般的Exchange没有区别，他能在任何队列上被指定，实际上就是设置某个队列的属性。<br>当这个队列有死信时，RabbitMQ就会自动将这个消息发布到设置的Exchange上去，进而路由到另一个队列。<br>变成死信队列有以下几种情况：  </p><ul><li>消息被拒绝（basic.reject/basic.nack)并且requeue = false。</li><li>消息TTL过期</li><li>队列达到最大长度</li></ul><p>延迟队列:</p><ul><li>消息的延迟推送</li><li>定时任务的执行</li><li>业务削峰限流，降级的异步延迟消息机制</li></ul><h2 id="使用了消息队列会有什么缺点"><a href="#使用了消息队列会有什么缺点" class="headerlink" title="使用了消息队列会有什么缺点?"></a>使用了消息队列会有什么缺点?</h2><h2 id="RabbitMQ-中的-cluster、mirrored-queue，以及-warrens-机制分别用于解决什么问题？存在哪些问题？"><a href="#RabbitMQ-中的-cluster、mirrored-queue，以及-warrens-机制分别用于解决什么问题？存在哪些问题？" class="headerlink" title="RabbitMQ 中的 cluster、mirrored queue，以及 warrens 机制分别用于解决什么问题？存在哪些问题？"></a>RabbitMQ 中的 cluster、mirrored queue，以及 warrens 机制分别用于解决什么问题？存在哪些问题？</h2><p>cluster 是为了解决当 cluster 中的任意 node 失效后，producer 和 consumer 均可以</p><p>通过其他 node 继续工作，即提高了可用性；另外可以通过增加 node 数量增加 cluster</p><p>的消息吞吐量的目的。cluster 本身不负责 message 的可靠性问题（该问题由 producer 通</p><p>过各种机制自行解决）；cluster 无法解决跨数据中心的问题（即脑裂问题）。另外，在</p><p>cluster 前使用 HAProxy 可以解决 node 的选择问题，即业务无需知道 cluster 中多个</p><p>node 的 ip 地址。可以利用 HAProxy 进行失效 node 的探测，可以作负载均衡。下图为</p><p>HAProxy + cluster 的模型。</p><p>Mirrored queue 是为了解决使用 cluster 时所创建的 queue 的完整信息仅存在于单一</p><p>node 上的问题，从另一个角度增加可用性。若想正确使用该功能，需要保证：1.consumer</p><p>需要支持 Consumer Cancellation Notification 机制；2.consumer 必须能够正确处理重复</p><p>message 。</p><p>Warrens 是为了解决 cluster 中 message 可能被 blackholed 的问题，即不能接受</p><p>producer 不停 republish message 但 RabbitMQ server 无回应的情况。Warrens 有两种构</p><p>成方式，一种模型是两台独立的 RabbitMQ server + HAProxy ，其中两个 server 的状态分</p><p>别为 active 和 hot-standby 。该模型的特点为：两台 server 之间无任何数据共享和协议</p><p>交互，两台 server 可以基于不同的 RabbitMQ 版本。如下图所示</p><p>另一种模型为两台共享存储的 RabbitMQ server + keepalived ，其中两个 server 的状态分</p><p>别为 active 和 cold-standby 。该模型的特点为：两台 server 基于共享存储可以做到完全</p><p>恢复，要求必须基于完全相同的 RabbitMQ 版本。如下图所示</p><p>Warrens 模型存在的问题：对于第一种模型，虽然理论上讲不会丢失消息，但若在该模型</p><p>上使用持久化机制，就会出现这样一种情况，即若作为 active 的 server 异常后，持久化</p><p>在该 server 上的消息将暂时无法被 consume ，因为此时该 queue 将无法在作为 hot-</p><p>standby 的 server 上被重建，所以，只能等到异常的 active server 恢复后，才能从其上的</p><p>queue 中获取相应的 message 进行处理。而对于业务来说，需要具有：a.感知 AMQP 连</p><p>接断开后重建各种 fabric 的能力；b.感知 active server 恢复的能力；c.切换回 active</p><p>server 的时机控制，以及切回后，针对 message 先后顺序产生的变化进行处理的能力。</p><p>对于第二种模型，因为是基于共享存储的模式，所以导致 active server 异常的条件，可能</p><p>同样会导致 cold-standby server 异常；另外，在该模型下，要求 active 和 cold-standby</p><p>的 server 必须具有相同的 node 名和 UID ，否则将产生访问权限问题；最后，由于该模</p><p>型是冷备方案，故无法保证 cold-standby server 能在你要求的时限内成功启动。</p><h2 id="为什么不应该对所有的-message-都使用持久化机制？"><a href="#为什么不应该对所有的-message-都使用持久化机制？" class="headerlink" title="为什么不应该对所有的 message 都使用持久化机制？"></a>为什么不应该对所有的 message 都使用持久化机制？</h2><p>假如有这样一个场景，当有大量的消息在1秒的时间到达，这样就很有可能导致消息丢失，但如果你使用持久化机制，将会导致rabbitmq整个性能急剧下降。有其他解决方式为生产者可以在单独的信道上监听应答队列。每次发送消息带上应答队列的名字，消费者消费了消息，就回发应答确认接收到了。如果消息应答未在合理时间内接收，则重新发送该条消息。持久化机制更多是一些关键的消息，并发量不大，但会通用并不可丢失。</p><h2 id="Basic-Reject-的用法是什么？"><a href="#Basic-Reject-的用法是什么？" class="headerlink" title="Basic.Reject 的用法是什么？"></a>Basic.Reject 的用法是什么？</h2><p>该信令可用于 consumer 对收到的 message 进行 reject 。若在该信令中设置requeue=true，则当 RabbitMQ server 收到该拒绝信令后，会将该 message 重新发送到下一个处于 consume 状态的 consumer 处（理论上仍可能将该消息发送给当前consumer）。若设置 requeue=false ，则 RabbitMQ server 在收到拒绝信令后，将直接将该message 从 queue 中移除。另外一种移除 queue 中 message 的小技巧是，consumer 回复 Basic.Ack 但不对获取到的message 做任何处理。而 Basic.Nack 是对 Basic.Reject 的扩展，以支持一次拒绝多条 message 的能力。</p><h2 id="Consumer-Cancellation-Notification-机制用于什么场景？"><a href="#Consumer-Cancellation-Notification-机制用于什么场景？" class="headerlink" title="Consumer Cancellation Notification 机制用于什么场景？"></a>Consumer Cancellation Notification 机制用于什么场景？</h2><h2 id="什么情况下会出现-blackholed-问题？"><a href="#什么情况下会出现-blackholed-问题？" class="headerlink" title="什么情况下会出现 blackholed 问题？"></a>什么情况下会出现 blackholed 问题？</h2><p>blackholed 问题是指，向 exchange 投递了 message ，而由于各种原因导致该message 丢失，但发送者却不知道。可导致 blackholed 的情况：  </p><ol><li>向未绑定 queue 的exchange 发送 message；  </li><li>exchange 以 binding_key key_A 绑定了 queue queue_A，但向该 exchange 发送 message 使用的 routing_key 却是 key_B。</li></ol><h2 id="如何防止出现-blackholed-问题？"><a href="#如何防止出现-blackholed-问题？" class="headerlink" title="如何防止出现 blackholed 问题？"></a>如何防止出现 blackholed 问题？</h2><p>没有特别好的办法，只能在具体实践中通过各种方式保证相关 fabric 的存在。另外，</p><p>如果在执行 Basic.Publish 时设置 mandatory=true ，则在遇到可能出现 blackholed 情况</p><p>时，服务器会通过返回 Basic.Return 告之当前 message 无法被正确投递（内含原因 312</p><p>NO_ROUTE）。</p><h2 id="为什么说保证-message-被可靠持久化的条件是-queue-和-exchange-具有durable-属性，同时-message-具有-persistent-属性才行？"><a href="#为什么说保证-message-被可靠持久化的条件是-queue-和-exchange-具有durable-属性，同时-message-具有-persistent-属性才行？" class="headerlink" title="为什么说保证 message 被可靠持久化的条件是 queue 和 exchange 具有durable 属性，同时 message 具有 persistent 属性才行？"></a>为什么说保证 message 被可靠持久化的条件是 queue 和 exchange 具有durable 属性，同时 message 具有 persistent 属性才行？</h2><p>若 exchange 或 queue 未设置</p><p>durable 属性，则在其 crash 之后就会无法恢复，那么即使 message 设置了 persistent 属</p><p>性，仍然存在 message 虽然能恢复但却无处容身的问题；同理，若 message 本身未设置</p><p>persistent 属性，则 message 的持久化更无从谈起。</p><h2 id="“dead-letter”queue-的用途？"><a href="#“dead-letter”queue-的用途？" class="headerlink" title="“dead letter”queue 的用途？"></a>“dead letter”queue 的用途？</h2><h2 id="向不存在的-exchange-发-publish-消息会发生什么？向不存在的-queue-执行consume-动作会发生什么？"><a href="#向不存在的-exchange-发-publish-消息会发生什么？向不存在的-queue-执行consume-动作会发生什么？" class="headerlink" title="向不存在的 exchange 发 publish 消息会发生什么？向不存在的 queue 执行consume 动作会发生什么？"></a>向不存在的 exchange 发 publish 消息会发生什么？向不存在的 queue 执行consume 动作会发生什么？</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化机制</title>
      <link href="/1024-xy.github.io/2019/11/23/redis-chi-jiu-hua-ji-zhi/"/>
      <url>/1024-xy.github.io/2019/11/23/redis-chi-jiu-hua-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h1><p>redis是单线程，高性能的，并且是拥有持久化机制的nosql内存数据库  </p><p><img src="https://img13.360buyimg.com/img/jfs/t1/95955/22/2863/116781/5dd78426E5176373a/881653889d55d0d5.png" alt="持久化机制.png">  </p><h2 id="为什么Redis单线程但却速度很快呢？？"><a href="#为什么Redis单线程但却速度很快呢？？" class="headerlink" title="为什么Redis单线程但却速度很快呢？？"></a>为什么Redis单线程但却速度很快呢？？</h2><ul><li>基于内存操作，速度非常快</li><li>采用单线程，避免上下文切换导致消耗CPU</li><li>采用单线程，不用去考虑各种加锁释放锁的问题</li><li>使用IO多路复用，非阻塞IO</li></ul><h3 id="什么是Redis-IO多路复用"><a href="#什么是Redis-IO多路复用" class="headerlink" title="什么是Redis IO多路复用"></a>什么是Redis IO多路复用</h3><p>redis的io模型是基于epoll实现，不过也提供了select和kqueue的实现，默认采用epoll。</p><p>epoll的优点：  </p><ol><li>epoll没有最大并发连接限制，上限是最大可以打开文件的数目，这个数字一般远大于2048，一般来说这个数目和系统内存关系很大</li><li>效率提升，Epoll最大的优点就在于它只管你“活跃的连接”，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</li><li>内存拷贝，Epoll在这点上使用了“共享内存”，这个内存拷贝也就省略了。  </li></ol><p>epoll详细可参考：<br><a href="https://blog.csdn.net/wxy941011/article/details/80274233" target="_blank" rel="noopener">epoll原理解析</a><br><a href="https://blog.csdn.net/b1480521874/article/details/81368987" target="_blank" rel="noopener">mmap内存映射原理</a></p><h2 id="Redis设置外网访问"><a href="#Redis设置外网访问" class="headerlink" title="Redis设置外网访问"></a>Redis设置外网访问</h2><pre><code>1.注释bind并把protected no2.使用bind3.设置密码protected mode它启用的条件有两个，第一个是没有使用bind,第二个是没有设置访问密码。</code></pre><h2 id="Redis数据类型以及API操作参考文档"><a href="#Redis数据类型以及API操作参考文档" class="headerlink" title="Redis数据类型以及API操作参考文档"></a>Redis数据类型以及API操作<a href="http://redisdoc.com" target="_blank" rel="noopener">参考文档</a></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis常见问题</title>
      <link href="/1024-xy.github.io/2019/11/22/redis-chang-jian-mian-shi-ti/"/>
      <url>/1024-xy.github.io/2019/11/22/redis-chang-jian-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis常见问题"><a href="#Redis常见问题" class="headerlink" title="Redis常见问题"></a>Redis常见问题</h1><h2 id="什么是RDB持久化机制"><a href="#什么是RDB持久化机制" class="headerlink" title="什么是RDB持久化机制"></a>什么是RDB持久化机制</h2><p>原理：redis会单独创建一个子进程，该子进程与主进程一模一样，数据，环境变量都一样，子进程会先将数据写入到一个临时文件中，待持久化完成，再用这个临时文件替换持久化好的文件，整个过程，主进程不参与任何IO操作，极大的提高了性能。</p><h2 id="持久化文件在哪"><a href="#持久化文件在哪" class="headerlink" title="持久化文件在哪"></a>持久化文件在哪</h2><p>持久化文件在redis.conf中进行配置，一般在redis.config的相同目录下。</p><h2 id="什么时候会触发持久化机制"><a href="#什么时候会触发持久化机制" class="headerlink" title="什么时候会触发持久化机制"></a>什么时候会触发持久化机制</h2><ul><li><p>shutdown时，如果没有开启aof，会触发，但是kill不会触发</p></li><li><p>指定相应的参数会触发持久化机制如</p><p>  指定在多长时间内有多少次更新操作，就将数据同步到数据文件，可以配合多条使用，这里表示如果900秒内有一次更改。<br>  save 900 1<br>  save 300 10<br>  save 60 10000  </p></li><li><p>bgsave创建一个子进程去进行RDB持久化</p></li><li><p>save使用主进程去持久化（不推荐）</p></li></ul><h2 id="AOF持久化机制"><a href="#AOF持久化机制" class="headerlink" title="AOF持久化机制"></a>AOF持久化机制</h2><p>AOF将redis的操作日志以追加的方式写入文件，读操作不记录  </p><h3 id="AOF文件存储的是什么"><a href="#AOF文件存储的是什么" class="headerlink" title="AOF文件存储的是什么"></a>AOF文件存储的是什么</h3><pre><code>SET K1 V1*2 ## 命令的条数$6 ## 命令的长度SELECT ## 命令$10*3$3SET$2K1$2V1</code></pre><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><ul><li>no:表示等操作系统进行数据缓存到同步磁盘（快，持久化没保证）</li><li>always:同步持久化，每次发生数据变更时，立即记录到磁盘（慢，安全）</li><li>everysec:表示每秒同步一次（默认，很快，但可能会丢失一秒以内的数据）</li></ul><h3 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h3><p>AOF重写是指将一些指令进行优化，比如对一个数增加100次，则可以直接使用set key 100。这样将极大减少AOF文件空间。<br>当AOF文件增长到一定大小的时候Redis能够调用bgrewriteaof对日志文件进行重写，当AOF大小大于该配置项的时候，启动重写（这里指超过原大小的100%）</p><pre><code>auto-aof-rewrite-percentage 100</code></pre><p>当AOF文件增长到一定大小的时候Redis能够调用bgrewriteaof日志文件进行重写。当AOF文件大小大于该项时自动启动重写</p><pre><code>auto-aof-rewrite-min-size 64mb</code></pre><p>当AOF文件达到64mb启动重写，假如重写到40mb，那么下次达到重写条件将会是40<em>2</em>auto-aof-rewrite-percentage也就是80mb在这里。</p><h2 id="混合持久化机制"><a href="#混合持久化机制" class="headerlink" title="混合持久化机制"></a>混合持久化机制</h2><p>通过下面参数配置控制</p><pre><code>aof-use-rdb-preamble #yes表示开启</code></pre><p>混合持久化是通过bgrewriteaof完成的，不同的是，当开启混合持久化机制时，fork出子进程先将共享的内容副本全量以RDB的方式写入AOF文件，然后再将重写缓冲区的增量命令以AOF方式写入到文件中，写入完成后 通知主进程更新统计信息，并将新的含有RDB和AOF格式的AOF文件替换旧的AOF文件，简单的说，新的AOF文件，前半段是全量的RDB数据，后半段是增量AOF数据。</p><ul><li>优点：混合持久化结合两者的优点，RDB加载速度快，同时结合了AOF，增量数据以AOF的方式保存了，数据更少的丢失。</li><li>缺点：兼容性差  </li></ul><h2 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h2><h3 id="Redis有了RDB持久化方案为什么还要AOF"><a href="#Redis有了RDB持久化方案为什么还要AOF" class="headerlink" title="Redis有了RDB持久化方案为什么还要AOF?"></a>Redis有了RDB持久化方案为什么还要AOF?</h3><p>数据丢失问题，RDB丢失最后一次快照数据，AOF丢失不会超过2秒的数据</p><h3 id="如果AOF和RDB同时存在，听谁的？"><a href="#如果AOF和RDB同时存在，听谁的？" class="headerlink" title="如果AOF和RDB同时存在，听谁的？"></a>如果AOF和RDB同时存在，听谁的？</h3><p>AOF</p><h3 id="RDB和AOF的优势劣势？"><a href="#RDB和AOF的优势劣势？" class="headerlink" title="RDB和AOF的优势劣势？"></a>RDB和AOF的优势劣势？</h3><p>RDB适合大规模数据恢复，对数据完整性和一致性不高，在一定间隔期间内做一次备份，如果使用RDB的话，就好丢失最后一次快照后的所有操作。<br>AOF根据配置项而定<br>官方建议 两种持久化机制同时开启。  </p><h2 id="集群详解："><a href="#集群详解：" class="headerlink" title="集群详解："></a>集群详解：</h2><h3 id="单机版"><a href="#单机版" class="headerlink" title="单机版"></a>单机版</h3><p>缺点</p><ul><li>单机故障</li><li>容量瓶颈</li><li>qps瓶颈 </li></ul><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>缺点：</p><ul><li>单机故障</li><li>容量瓶颈</li></ul><p>优点：</p><ul><li>读写分离</li><li>容灾备份</li></ul><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>使用哨兵集群节点监控主节点，一旦主节点发生故障，哨兵节点通过选举方式从从机中选出主节点顶替。<br>哨兵模式引入了主节点自动故障转移进一步提高了可用性，但是很明显：哨兵无法对从节点进行自动故障转移，在读写分离场景下，从节点故障会导致读服务不可用，此外，哨兵仍然无法解决写操作无法负载均衡，以及存储能力受到限制。</p><h3 id="cluster集群模式"><a href="#cluster集群模式" class="headerlink" title="cluster集群模式"></a>cluster集群模式</h3><p><img src="https://static001.infoq.cn/resource/image/f7/7c/f70609a78f2429832cec2ecf54707d7c.png" alt="cluster集群">    </p><p>Redis Cluster 特性之一是引入了槽的概念。一个 redis 集群包含 16384 个哈希槽，集群中的每个 redis 节点，分配到一部分槽。而集群使用公式 CRC16(key) % 16384 来计算每次请求的键 key 属于哪个槽，通过查询集群配置，便可知道 key 对应的槽属于哪个 redis 节点，然后再将请求打到该节点。举个例子，一个集群可以有两个节点，其中：</p><ol><li>节点 A 负责处理 0 号至 5000 号哈希槽。</li><li>节点 B 负责处理 5001 号至 10000 号哈希槽。</li><li>节点 C 负责处理 10001 号至 16383 号哈希槽。</li></ol><p>通过上述公式，可对 key X 计算出一个值，该值为 0-16383 中的一个数。假设 key X 通过上述公式计算出来的值为 34，根据上面例子，34 即为槽标识，亦 key X 属于槽 34，而槽 34 分配到了节点 A，也就是说节点 A 负责 key X 的读写。</p><p>通过将哈希槽分布到不同节点，我们可以很容易地向集群中添加或者删除节点。比如说：</p><p>如果用户将新节点 D 添加到集群中，那么集群只需要将节点 A 、B、C 中的某些槽移动到节点 D 就可以了。</p><p>与此类似，如果用户要从集群中移除节点 A ，那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ，然后再移除节点 A 就可以了。</p><p>因为槽在节点之间移动不会造成节点阻塞，所以无论是添加新节点还是移除已存在节点，又或者改变某个节点包含的哈希槽数量，都不会造成集群下线，redis 集群能保证槽的平滑移动。</p><p>RedisCluster 还有一个特性便是去中心化。客户端可以连接集群中的任意一个节点，集群中的任意一个节点都可对外提供服务。节点之间可共享集群配置（如槽的分配）。或者我们可以理解为，集群中的任意一个节点都是中心节点。假设有两个节点 A 和 B，客户端连接了 A 节点，并发起了一次请求 a，A 节点计算请求 a 的 key 得知该请求应该打到 B 节点上，然后 A 节点对请求 a 返回一个 MOVED B，通知客户端重定向到 B 节点。  </p><h3 id="JedisCluster操作"><a href="#JedisCluster操作" class="headerlink" title="JedisCluster操作"></a>JedisCluster操作</h3><p><img src="https://img14.360buyimg.com/img/jfs/t1/101459/4/2806/670767/5dd7570bE9ac09889/687ee817c6245a27.png" alt="image.png">  </p><h3 id="Redis支持事务吗？"><a href="#Redis支持事务吗？" class="headerlink" title="Redis支持事务吗？"></a>Redis支持事务吗？</h3><p>半支持事务，提供了一些在一定程度上支持线程安全和事务的命令。例如：multi/exec wathch inc等，但redis事务并不支持回滚</p><h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>指数据库当中没有的数据，缓存也没有数据，这样一直访问一个不存在的数据，导致数据库读取压力增大。  </p><p>解决：   </p><ul><li>布隆过滤器：原理，通过redis位图，对其进行哈希，当访问过来，如果该数据不存在，则会过滤。  </li><li>缓存空对象</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指缓存中没有但数据库有的数据（一般是缓存时间到期），这时由于并发用户特别大，同时读缓存没有读到数据，又同时读取数据库，引起数据库压力瞬间增大，造成过大压力<br>解决方案：  </p><ul><li>使用分布式锁，或jvm同步锁</li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>指缓存服务器重启或大量缓存集中在某一个时间段内失效。<br>常用解决办法：</p><ol><li>主要就是要搭建高可用集群，保证机器高可用。</li><li>对不同数据使用不同的失效时间，甚至对相同的数据、不同的请求使用不同的失效时间。</li></ol><h3 id="缓存与数据库一致性"><a href="#缓存与数据库一致性" class="headerlink" title="缓存与数据库一致性"></a>缓存与数据库一致性</h3><p>不管先更新数据库还是先更新缓存都有问题，解决方案为先删除缓存，再修改数据库。如果数据库修改失败，那么数据事务回滚，数据库存的依然是旧数据，，缓存中是空的，那么在读取的时候会走数据库，再更新到缓存中，不会产生数据不一致的问题。  </p><p><img src="https://img10.360buyimg.com/img/jfs/t1/70318/27/15878/731643/5dd76a87E774d1852/9e0dc2a1a93da5a7.png" alt="image.png">  </p><p>最终 解决方案：</p><p>延时双删</p><p><img src="https://img12.360buyimg.com/img/jfs/t1/74410/18/15914/398811/5dd76b07E2f4a6699/36038ee63399a081.png" alt="image.png">  </p><p>串行化<br><img src="https://img12.360buyimg.com/img/jfs/t1/96519/34/2860/671459/5dd76b5fEebef85e5/ec69829ad0c2f9a5.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 缓存中间件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机基础</title>
      <link href="/1024-xy.github.io/2019/11/20/xu-ni-ji-ji-chu/"/>
      <url>/1024-xy.github.io/2019/11/20/xu-ni-ji-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="jvm虚拟机优化看这里！！！强烈推荐"><a href="#jvm虚拟机优化看这里！！！强烈推荐" class="headerlink" title="jvm虚拟机优化看这里！！！强烈推荐"></a>jvm虚拟机优化<a href="https://github.com/DC-Joney/java-note/blob/master/jvm/%E9%9D%A2%E8%AF%95.md" target="_blank" rel="noopener">看这里！！！强烈推荐</a></h1><p>通过自己jvm虚拟机的学习，我将分以下几点对虚拟机进行专门的巩固以及调优选择的见解。  </p><ol><li>虚拟机内存模型  </li><li>虚拟机类加载机制  </li><li>垃圾回收算法  <h2 id="虚拟机内存模型"><a href="#虚拟机内存模型" class="headerlink" title="虚拟机内存模型"></a>虚拟机内存模型</h2>首先我们需要了解的就是虚拟内存模型，虚拟机内存分为五块<br>共享区域：方法区（永久代）、堆内存<br>线程独享区域：程序计数器、虚拟机栈、本地方法栈<br><img src="http://images.cnitblog.com/blog/323385/201301/11195714-b322e28c32654753bcbacb5dcf9545f6.png" alt="虚拟机内存划分">  </li></ol><p>方法区：存放着一个class文件被加载进虚拟机之后的类的信息，常量池、方法信息、静态变量，静态方法等信息<br>    1. 类的信息方法信息如是否是public ,方法返回的类型等<br>    2. 静态变量为静态方法中声明的静态变量，类上声明的静态变量<br>    3. 常量池：运行时常量池，class常量池，全局字符串常量池。<br>常量池详解<a href="https://www.cnblogs.com/itplay/p/11137526.html" target="_blank" rel="noopener" title="常量池">https://www.cnblogs.com/itplay/p/11137526.html</a><br> <a href="https://blog.csdn.net/xiao______xin/article/details/81985654" target="_blank" rel="noopener">https://blog.csdn.net/xiao______xin/article/details/81985654</a><br>：<br><img src="https://img2018.cnblogs.com/blog/1111824/201904/1111824-20190422110927913-1003646094.png" alt="常量池"><br><strong>1. class常量池：</strong> 我们都知道，class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)。 字面量就是我们所说的常量概念，如文本字符串、被声明为final的常量值等。 符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）<br><strong>2. 动态常量池：</strong>当java文件被编译成class文件之后，也就是会生成我上面所说的class常量池，那么运行时常量池又是什么时候产生的呢？<br>jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。<br><strong>3. 全局字符串池：</strong>全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。java7已经将该区域转为到了堆中</p><p>堆区： 存有所有的字符串对象以及字符串池，然后再划分新生代、老年代。堆中分配内存对象有两种，一种是指针碰撞法，另一种是空间散列表法。</p><ul><li>指针碰撞法，通过两个指针不断移动，来分配合适的空间</li><li>空间散列表法，维护一个散列表，看已分配的空间的地址与未分配空间的地址。  </li></ul><p>指针碰撞法线程安全问题解决：为每个用户线程分配缓冲区，所产生的对象在该缓冲区内分配，缓冲区满了增加缓冲区。<br>空间散列表法线程安全问题解决：对空间散列表进行同步。  </p><ul><li>新生代：新生代分为Edden区与两个Survivor区，主要存放短期存活对象</li><li>老年代：主要存放长期存活对象 </li></ul><p>设置堆区大小：-Xms -Xmn<br>设置新生代大小：-Xmn<br>设置新生代对象进入老年代年龄：-XX:MaxTenuringThreshold<br>对象进入老年代条件： </p><ul><li>达到年龄  </li><li>当Survivor中相同年龄所有对象大小总和大于Survivor空间一半，年龄大于该年龄的对象直接进入老年代。  </li></ul><p>空间分配担保：在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有空间总和，如果条件程离，那么Minor GC是安全的，如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于则进行Minor GC 否则可能进行一次Full GC  </p><p>虚拟机栈：方法执行时会创建一个栈帧，栈帧的结构分为局部变量表，操作数栈，动态链接，方法出口  </p><p>程序计数器：记录执行到哪一条指令。<br>本地方法栈：执行c代码，与虚拟机栈区别不大。  </p><h2 id="虚拟机的类加载机制"><a href="#虚拟机的类加载机制" class="headerlink" title="虚拟机的类加载机制"></a>虚拟机的类加载机制</h2><p>类加载分为编译期、加载、验证、准备、解析、初始化这几个阶段。  </p><ol><li>编译期主要将.java文件编译成为.class文件  </li><li>加载主要将.class文件加载进jvm内存，但此时的class对象还不可用  </li><li>验证：检查.class文件的正确性，文件格式的验证、元信息的验证、字节码验证、符号引用验证。  </li><li>准备：对类信息分配内存空间并设置类变量的默认值，对static final String变量直接赋值，并放入常量池。  </li><li>初始化：初始化的时候先执行static代码块与给static变量赋值，在给其他变量赋值。</li></ol><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="判断哪些垃圾可回收"><a href="#判断哪些垃圾可回收" class="headerlink" title="判断哪些垃圾可回收"></a>判断哪些垃圾可回收</h3><p>可达性分析算法： 使用GCROOT作为根节点，从根节点出发，如果该对象没有根节点，则该对象以及引用该对象的对象都会被回收。<br>什么对象可以作为GCroot： 虚拟机栈中引用的对象，类静态属性引用的对象，常量引用的对象，本地方法栈中引用的对象。  </p><h3 id="有哪些垃圾回收算法？"><a href="#有哪些垃圾回收算法？" class="headerlink" title="有哪些垃圾回收算法？"></a>有哪些垃圾回收算法？</h3><p>复制算法：一般应用于新生代，通过将edden区与一块survior区进行垃圾回收将存活对象复制进另一块survior区<br>标记整理算法：一般用于老年代，将垃圾对象回收，将存活对象进行整理。  </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/1024-xy.github.io/2019/11/09/hello-world-2/"/>
      <url>/1024-xy.github.io/2019/11/09/hello-world-2/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper分布式原理与应用</title>
      <link href="/1024-xy.github.io/2019/11/01/zookeeper-gong-zuo-yuan-li-yu-ying-yong-2/"/>
      <url>/1024-xy.github.io/2019/11/01/zookeeper-gong-zuo-yuan-li-yu-ying-yong-2/</url>
      
        <content type="html"><![CDATA[<h1 id="zookeeper分布式原理与应用"><a href="#zookeeper分布式原理与应用" class="headerlink" title="zookeeper分布式原理与应用"></a>zookeeper分布式原理与应用</h1><h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><hr><p>&emsp;&emsp;假设我们有20个搜索引擎的服务器（每个负责总索引中的一部分搜索任务）和一个总服务器（负责向这20个搜索引擎的服务器发出搜索请求并合并 结果集），一个备用的总服务器（负责总服务器宕机时替换总服务器），一个web cli（向总服务器发出搜索请求）。搜索引擎的服务器中的15个服务器现在提供搜索服务，5个服务器正在生成索引。这20个搜索引擎的服务器经常要让正在 提供搜索服务的服务器停止提供服务开始生成索引,或生成索引的服务器已经把索引生成完成可以搜索提供服务了.使用Zookeeper可以保证总服务器自动 感知有多少提供搜索引擎的服务器并向这些服务器发出搜索请求,备用的总服务器宕机时自动启用备用的总服务器,web的cgi能够自动地获知总服务器的网络地址变化.这些又如何做到呢?   </p><ol><li>提供搜索引擎的服务器都在Zookeeper中创建znode,zk.create(“/search/nodes/node1”,</li></ol><p>“hostname”.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateFlags.EPHEMERAL);</p><ol start="2"><li><p>总服务器可以从Zookeeper中获取一个znode的子节点的列表,zk.getChildren(“/search/nodes”, true);</p></li><li><p>总服务器遍历这些子节点,并获取子节点的数据生成提供搜索引擎的服务器列表.</p></li><li><p>当总服务器接收到子节点改变的事件信息,重新返回第二步.</p></li><li><p>总服务器在Zookeeper中创建节点,zk.create(“/search/master”, “hostname”.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateFlags.EPHEMERAL);</p></li><li><p>备用的总服务器监控Zookeeper中的”/search/master”节点.当这个znode的节点数据改变时,把自己启动变成总服务器,并把自己的网络地址数据放进这个节点.</p></li><li><p>web的cgi从Zookeeper中”/search/master”节点获取总服务器的网络地址数据并向其发送搜索请求.</p></li><li><p>web的cgi监控Zookeeper中的”/search/master”节点,当这个znode的节点数据改变时,从这个节点获取总服务器的网络地址数据,并改变当前的总服务器的网络地址.  </p></li></ol><h3 id="Zookeeper的功能有哪些"><a href="#Zookeeper的功能有哪些" class="headerlink" title="Zookeeper的功能有哪些"></a>Zookeeper的功能有哪些</h3><hr><h4 id="1、文件系统"><a href="#1、文件系统" class="headerlink" title="1、文件系统"></a>1、文件系统</h4><p>zookeeper维护了一个类似文件系统的数据结构：<br><img src="http://static.open-open.com/lib/uploadImg/20141108/20141108213344_45.png" alt="zookeeper图片"><br>&emsp;&emsp;每个子目录项以及其下的子节点都是一个znode，我们能对这些znodes进行增删查改的操作，并且能够存储数据。<br>有四种类型的znode:  </p><p>1、PERSISTENT-持久化目录节点</p><p>客户端与zookeeper断开连接后，该节点依旧存在</p><p>2、 PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点</p><p>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</p><p>3、EPHEMERAL-临时目录节点</p><p>客户端与zookeeper断开连接后，该节点被删除</p><p>4、EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</p><p>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号  </p><h4 id="2、通知机制"><a href="#2、通知机制" class="headerlink" title="2、通知机制"></a>2、通知机制</h4><p>&emsp;&emsp;客户端注册监听它关心的目录节点，一旦发生变化（数据变化，删除，子目录增加）时，zookeeper节点会通知客户端。  </p><h3 id="Zookeeper的可以用来做什么？"><a href="#Zookeeper的可以用来做什么？" class="headerlink" title="Zookeeper的可以用来做什么？"></a>Zookeeper的可以用来做什么？</h3><hr><h4 id="1、服务注册与发现"><a href="#1、服务注册与发现" class="headerlink" title="1、服务注册与发现"></a>1、服务注册与发现</h4><p>使用doubbo、kafuka等rpc框架进行对象以及数据的传输，在这个过程中，可以使用zookeeper进行服务的注册以及订阅，rpc框架在zoookeeper发布服务的地址，方法，类名。同样的rpcc框架的客户端在zookeeper监听该服务是否存在，然后拿到服务的地址，与rpc框架的服务端进行对象的传输。如果含有多个相同服务，则可以进行权重配比。</p><h4 id="2、配置中心"><a href="#2、配置中心" class="headerlink" title="2、配置中心"></a>2、配置中心</h4><p>所有程序都免不了配置，当你去要做一些开关去开启或者关闭某些功能的时候，以及一些服务器的配置，都可以放入zookeeper的某个节点目录中进行统一管理，当配置信息被改变将会通知各个客户端，更改其服务器配置。<br><img src="https://www.aboutyun.com/data/attachment/forum/201608/20/184509blnln2a7n5qqa95s.png" alt="zookeeper配置中心"></p><h4 id="3、zookeeper集群管理"><a href="#3、zookeeper集群管理" class="headerlink" title="3、zookeeper集群管理"></a>3、zookeeper集群管理</h4><p>zookeeper对于集群的管理就两点：是否有加入新的节点，和选举master。<br>对于第一点：所有机器约定在主节点上的GroupMembers下创建临时目录节点，然后监听父目录的子节点变化消息，一旦有机器挂掉，则临时节点删除，其他机器收到通知。当然新机器也是类似，对于第二点，每次选举最小编号的机器作为主节点就好<br><img src="http://www.aboutyun.com/data/attachment/forum/201608/20/184530b6abmegbk09ffgva.png" alt="zookeeper配置"></p><h4 id="4、zookeeper分布式锁"><a href="#4、zookeeper分布式锁" class="headerlink" title="4、zookeeper分布式锁"></a>4、zookeeper分布式锁</h4><p>zookeeper有两种分布式锁，一种保持独占，一种控制时序。<br>对于第一类，我们将一个临时znode看所一把锁，客户端尝试建立该节点，建立成功的拿到锁，获取资源。创建失败的则进行等待，对于第二类，则在其一个目录节点下面创建多个顺序节点，如果是读，前面几个节点都是读操作，则可以同时拿到资源，如果都是写，则进行独占。  </p><p><img src="http://www.aboutyun.com/data/attachment/forum/201608/20/184557iv77xzbyas7bc99o.png" alt="分布式锁"></p><h4 id="5、队列管理功能"><a href="#5、队列管理功能" class="headerlink" title="5、队列管理功能"></a>5、队列管理功能</h4><ol><li>同步队列<br>&emsp;&emsp;当一个对列成员都到达，这个队列才被视为可用队列。其具体实现为：在约定目录下创建临时目录节点，监听节点数目是否是我们要求的数目。 </li><li>队列按照FIFO方式进行入队和出队操作。<br>&emsp;&emsp;和分布式锁服务中的控制时序场景基本原理一致，入列有编号，出列按编号。  </li></ol><h3 id="分布式的数据与复制"><a href="#分布式的数据与复制" class="headerlink" title="分布式的数据与复制"></a>分布式的数据与复制</h3><p>Zookeeper作为一个集群提供一致的数据服务，自然，它要在所有机器间做数据复制。数据复制的好处：<br>1、容错<br>一个节点出错，不至于整个系统崩溃，别的节点可以接管他的工作。<br>2、提高性能<br>让客户端本地访问就近的节点，提高用户访问速度。  </p><h3 id="数据一致性与paxos算法"><a href="#数据一致性与paxos算法" class="headerlink" title="数据一致性与paxos算法"></a>数据一致性与paxos算法</h3><p> 据说Paxos算法的难理解与算法的知名度一样令人敬仰，所以我们先看如何保持数据的一致性，这里有个原则就是：  </p><p> 在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。<br> Paxos算法解决的什么问题呢，解决的就是保证每个节点执行相同的操作序列。好吧，这还不简单，master维护一个全局写队列，所有写操作都必须放入这个队列编号，那么无论我们写多少个节点，只要写操作是按编号来的，就能保证一致性。</p><p> 没错，就是这样，可是如果master挂了呢。Paxos算法通过投票来对写操作进行全局编号，同一时刻，只有一个写操作被批准，同时并发的写操作要去争取选票，只有获得过半数选票的写操作才会被批准（所以永远只会有一个写操作得到批准），其他的写操作竞争失败只好再发起一轮投票，就这样，在日复一日年复一年的投票中，所有写操作都被严格编号排序。编号严格递增，当一个节点接受了一个编号为100的写操作，之后又接受到编号为99的写操作（因为网络延迟等很多不可预见原因），它马上能意识到自己数据不一致了，自动停止对外服务并重启同步过程。任何一个节点挂掉都不会影响整个集群的数据一致性（总2n+1台，除非挂掉大于n台）。  </p><h3 id="Zookeeper的工作原理（ZAB协议）"><a href="#Zookeeper的工作原理（ZAB协议）" class="headerlink" title="Zookeeper的工作原理（ZAB协议）"></a>Zookeeper的工作原理（ZAB协议）</h3><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p> zookeeper中的角色主要有以下三类，如下表所示：  </p><p> <img src="http://static.open-open.com/lib/uploadImg/20141108/20141108213346_932.png" alt="角色"><br> 系统模型如图所示：<br> <img src="http://static.open-open.com/lib/uploadImg/20141108/20141108213346_540.jpg" alt="zookeeper系统模型">  </p><h4 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h4><ol><li>最终一致性：client端不论连接到哪个server,展示给他的都是同一视图以及同一数据，这是zookeeper最重要的功能。</li><li>可靠性：zookeeper具有简单、健壮、良好的性能，如果消息m被一台服务器接受，那么它将被所有的服务器接受。</li><li>实时性：Zookeeper保证客户端将在一个时间间隔范围内获得服务器的更新信息，或者服务器失效的信息。但由于网络延时等原因，Zookeeper不能保证两个客 户端能同时得到刚更新的数据，如果需要最新数据，应该在读数据之前调用sync()接口。</li><li>等待无关性：慢的或者失效的client端的请求不得干预快速的client端的请求，使得每个client都能有效的等待。</li><li>原子性：更新数据或者节点只能成功或者失败。</li><li>顺序性：全局有序性是指如果一台服务器上的消息a在消息b之前发布，则所有服务器上的消息发布都要保持该顺序。<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4>Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分 别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的 状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系 统状态。<br>为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上 了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个 新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</li></ol><p>每个Server在工作过程中有三种状态：</p><p>LOOKING：当前Server不知道leader是谁，正在搜寻<br>LEADING：当前Server即为选举出来的leader<br>FOLLOWING：leader已经选举出来，当前Server与之同步</p><h5 id="选主流程"><a href="#选主流程" class="headerlink" title="选主流程"></a>选主流程</h5><hr><p>当leader崩溃或者失去大部分follower,这时候zk进入恢复模式，恢复模式重新选举出一个新的master,让所有的server恢复到一个正确的状态。zk的选举算法有两种：一种基于basic paxos算法实现，另一种基于fast paxos算法实现。系统默认选举算法为fast paxos算法。先介绍basic paxos流程：  1. 选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server；</p><ol start="2"><li><p>选举线程首先向所有Server发起一次询问(包括自己)；</p></li><li><p>选举线程收到回复后，验证是否是自己发起的询问(验证zxid是否一致)，然后获取对方的id(myid)，并存储到当前询问对象列表中，最后获取对方提议的leader相关信息(        id,zxid)，并将这些信息存储到当次选举的投票记录表中；</p></li><li><p>收到所有Server回复以后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server；</p></li><li><p>线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2 + 1的Server票数， 设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。</p></li></ol><p>&emsp;&emsp;通过流程分析我们可以得出：要使Leader获得多数Server的支持，则Server总数必须是奇数2n+1，且存活的Server的数目不得少于n+1.</p><p>每个Server启动后都会重复以上流程。在恢复模式下，如果是刚从崩溃状态恢复的或者刚启动的server还会从磁盘快照中恢复数据和会话信息，zk会记录事务日志并定期进行快照，方便在恢复时进行状态恢复。选主的具体流程图如下所示：  </p><p><img src="http://static.open-open.com/lib/uploadImg/20141108/20141108213346_59.png" alt="basic paxos"><br> fast paxos流程是在选举过程中，某Server首先向所有Server提议自己要成为leader，当其它Server收到提议以后，解决epoch和 zxid的冲突，并接受对方的提议，然后向对方发送接受提议完成的消息，重复这个流程，最后一定能选举出Leader。其流程图如下所示：<br> <img src="http://static.open-open.com/lib/uploadImg/20141108/20141108213346_900.png" alt="fast paxos">  </p><h5 id="同步流程"><a href="#同步流程" class="headerlink" title="同步流程"></a>同步流程</h5><hr><p> 选完leader以后，zk就进入状态同步过程。</p><ol><li><p>leader等待server连接；</p><p>2 .Follower连接leader，将最大的zxid发送给leader；</p><p>3 .Leader根据follower的zxid确定同步点；</p><p>4 .完成同步后通知follower 已经成为uptodate状态；</p><p>5 .Follower收到uptodate消息后，又可以重新接受client的请求进务了。<br><img src="http://static.open-open.com/lib/uploadImg/20141108/20141108213347_647.jpg" alt="同步流程">  </p><h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><h6 id="Leader工作流程"><a href="#Leader工作流程" class="headerlink" title="Leader工作流程"></a>Leader工作流程</h6><p>Leader主要有三个功能：</p><p>1 .恢复数据；</p><p>2 .维持与Learner的心跳，接收Learner请求并判断Learner的请求消息类型；</p><p>3 .Learner的消息类型主要有PING消息、REQUEST消息、ACK消息、REVALIDATE消息，根据不同的消息类型，进行不同的处理。</p><p>PING消息是指Learner的心跳信息；REQUEST消息是Follower发送的提议息，包括写请求及同步请求；ACK消息是Follower的对提议的回复，超过半数的Follower通过，则commit该提议；REVALIDATE消息是用来延长SESSION有效时间。<br>Leader的工作流程简图如下所示，在实际实现中，流程要比下图复杂得多，启动了三个线程来实现功能。  </p></li></ol><p><img src="http://static.open-open.com/lib/uploadImg/20141108/20141108213347_829.png" alt="leader流程">  </p><h6 id="follower工作流程"><a href="#follower工作流程" class="headerlink" title="follower工作流程"></a>follower工作流程</h6><p>Follower主要有四个功能：</p><pre><code>1. 向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；2 .接收Leader消息并进行处理；3 .接收Client的请求，如果为写请求，发送给Leader进行投票；4 .返回Client结果。</code></pre><p>Follower的消息循环处理如下几种来自Leader的消息：</p><pre><code>1 .PING消息： 心跳消息；2 .PROPOSAL消息：Leader发起的提案，要求Follower投票；3 .COMMIT消息：服务器端最新一次提案的信息；4 .UPTODATE消息：表明同步完成；5 .REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；6 .SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。</code></pre><p>Follower的工作流程简图如下所示，在实际实现中，Follower是通过5个线程来实现功能的。  </p><p><img src="http://static.open-open.com/lib/uploadImg/20141108/20141108213347_577.png" alt="follower"></p><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p> <a href="https://blog.csdn.net/lingbo229/article/details/81052078" target="_blank" rel="noopener">https://blog.csdn.net/lingbo229/article/details/81052078</a><br> <a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">http://zookeeper.apache.org/</a><br> <a href="http://blog.csdn.net/cutesource/article/details/5822459" target="_blank" rel="noopener">http://blog.csdn.net/cutesource/article/details/5822459</a><br> <a href="http://blog.csdn.net/pwlazy/article/details/8080626" target="_blank" rel="noopener">http://blog.csdn.net/pwlazy/article/details/8080626</a><br> <a href="http://nileader.blog.51cto.com/1381108/795265" target="_blank" rel="noopener">http://nileader.blog.51cto.com/1381108/795265</a><br> <a href="http://nileader.blog.51cto.com/1381108/926753" target="_blank" rel="noopener">http://nileader.blog.51cto.com/1381108/926753</a><br> <a href="http://nileader.blog.51cto.com/1381108/795230" target="_blank" rel="noopener">http://nileader.blog.51cto.com/1381108/795230</a><br> <a href="http://netcome.iteye.com/blog/1474255" target="_blank" rel="noopener">http://netcome.iteye.com/blog/1474255</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式中间件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP</title>
      <link href="/1024-xy.github.io/2019/11/01/springaop/"/>
      <url>/1024-xy.github.io/2019/11/01/springaop/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Aop"><a href="#Spring-Aop" class="headerlink" title="Spring Aop"></a>Spring Aop</h1><p>Aop,面向切面编程，是对OOP编程的一种补充，AOP是一个术语，表示从业务逻辑中横切出来的逻辑，比如性能监控、日志记录、权限控制等。其实AOP的最终原理是动态代理</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>以下代码是最原始的静态代理   </p><pre><code>//首先我们先定义一个接口public interface Greeting{    void sayHello(String name);}//创建一个实现类public class GreetingImpl implements Greeting{    public void sayHello(String name){        System.out.println(&quot;Hello&quot; + name);    }}//为实现类创建一个代理类public class GreetingProxy implements Greeting{    private GreetingImpl greetingImpl;    public GreetingProxy(GreetingImpl greetingImpl){        this.greetingImpl = greetingImpl;    }    public void sayHello(String name){        before();        greetingImpl.sayHello(name);        after();    }    private void before(){        System.out.println(&quot;Before&quot;);    }    private void after(){        System.out.println(&quot;after&quot;);    }}</code></pre><p>这样我们实现了一个简单的静态代理类，我们将会这样调用它：</p><pre><code>public class Client{    public static void main(String[] args){        Greeting greetingProxy = new GreetingProxy(new GreetingImpl);        greetingProxy.sayHello(&quot;Jack&quot;);    }}</code></pre><p>这样将会导致代理会越来越多，怎么将这些代理类复用成一个代理类呢？？</p><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>一下代码实现了一个JDK动态代理类：</p><pre><code>public class JDKDynamicProxy implements InvocationHandler{    private Object target;    public JDKDynamicProxy(Object target){        this.target = target;    }    public &lt;T&gt; T getProxy(){        return (T) Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInstances(),this)     }    @Override    public Object invoke(Object proxy, Method method, Object[] args} throws Throwable{        before();        Object result = method.invoke(taget, args);        after();        return result;    }    private void before(){        System.out.println(&quot;Before&quot;);    }    private void after(){        System.out.println(&quot;after&quot;);    }}//客户端进行调用public class Client{    public static void main(String[] args){        Greeting greeting = new JDKDynamicProxy(new GreetingImpl()).getProxy();        greeting.sayHello(&quot;JACK&quot;);    }}</code></pre><p>这样同样存在问题：JDK给我们提供的动态代理只能代理接口，不能代理没有接口的类。</p><h2 id="CGLib动态代理"><a href="#CGLib动态代理" class="headerlink" title="CGLib动态代理"></a>CGLib动态代理</h2><p>CGLib动态代理是基于继承实现，他的目标是针对需要代理的类生成一个子类，并覆盖其中的方法进行增强，但他不能对final的类实现代理，因为final类不能继承。那为什么有了CGLib还需要JDK动态代理呢？原因是，CGLib每次会生成字节码子类，所以加载很慢，但一旦其运行会比JDK快，两种各有优势。</p><pre><code>public class CGLibDynamicProxy implements MethodInterceptor{    private static CGLibDynamicProxy instance = new CGLibDynamicProxy();    private CGLibDynamicProxy(){    }    private static CGLibDynamicProxy getInstance(){        return instance;    }    @SuppressWarings(&quot;unchecked&quot;)    public &lt;T&gt; T getProxy(Class&lt;T&gt; cls){        return (T) Enhancer.create(cls, this);    }    @Override    public Object intercept(Object target, Method method, Object[] args, MethodProxy proxy) throws Throwable{        before();        Object result = proxy.invokeSuper(target, args);        after();        return result;    }    private void before(){        System.out.println(&quot;Before&quot;);    }    private void after(){        System.out.println(&quot;after&quot;);    }}//客户端进行调用public class Client{    public static void main(String[] args){        Greeting greeting = CGLibDynamicProxy.getInstance().getroxy(GreetingImpl.class);        greeting.sayHello(&quot;JACK&quot;);    }}</code></pre><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p>Spring AOP分为前置增强，后置增强，环绕增强。  </p><p>先来一个前置增强类：</p><p><img src="https://img11.360buyimg.com/img/jfs/t1/62497/14/15024/181402/5dca1461Ec9c2de9a/559621d39fc15390.png" alt="image.png"></p><p>再来一个后置增强类：</p><p><img src="https://img14.360buyimg.com/img/jfs/t1/96466/17/2053/278116/5dca1530E00905625/72f536d320319731.png" alt="image.png"></p><p>最后用客户端把它们集成起来：<br><img src="https://img12.360buyimg.com/img/jfs/t1/92252/7/2021/301032/5dca1571E54fc7807/7886cd7b66529939.png" alt="image.png"></p><p>当然我们完全可只定义一个增强类：</p><p><img src="https://img11.360buyimg.com/img/jfs/t1/58281/34/15701/693744/5dca15f6E2f31b28a/c7d8207fa78a99e0.png" alt="image.png"><br>以上是编程式的AOP用法，但Spring同样集成了配置文件来定义Bean对象</p><p><img src="https://img11.360buyimg.com/img/jfs/t1/95189/13/2087/573169/5dca167bE21053b49/856ad094c9422bab.png" alt="image.png">  </p><h3 id="Spring-AOP抛出增强"><a href="#Spring-AOP抛出增强" class="headerlink" title="Spring AOP抛出增强"></a>Spring AOP抛出增强</h3><p>程序报错了，抛出异常我们一般需要记录日志，这样我们得使用抛出增强；</p><p><img src="https://img11.360buyimg.com/img/jfs/t1/105464/8/2112/245753/5dca1764E8c59099d/7190416b4ec3a295.png" alt="image.png"></p><p>下面是抛出增强类的代码：</p><p><img src="https://img14.360buyimg.com/img/jfs/t1/106121/17/2093/235779/5dca178eEc114c67c/31ddf206fc7ede57.png" alt="image.png">  </p><p>抛出增强类需要实现ThrowsAdvice接口,在接口方法中可以获取方法，参数，目标对象等信息，我们可以统一将这些信息写入日志中。</p><h3 id="Spring-AOP引入增强"><a href="#Spring-AOP引入增强" class="headerlink" title="Spring AOP引入增强"></a>Spring AOP引入增强</h3><p>以上代码都是对方法的增强，那能否对类进行增强呢？我们可以使用Spring AOP的引入增强<br>定义一个新的接口：  </p><pre><code>public interface Apology{    void saySorry(String name);}</code></pre><p>但我们不想在代码中让GreetingImpl去实现它，而是想要程序运行的时候动态实现它。因为假如实现了这个接口，那么就一定要改写GreetingImpl这个类。下面我们使用引入增强：<br><img src="https://img12.360buyimg.com/img/jfs/t1/104632/14/2078/237423/5dca1cabEf58d7e11/a9aac8dbd850388f.png" alt="image.png">  </p><p>看看如何配置的<br><img src="https://img12.360buyimg.com/img/jfs/t1/87856/39/2034/423753/5dca1d41E5ab5c2f9/3aab016b1cd09449.png" alt="image.png"><br>需要注意proxyTargetClass属性，它表明是否为代理目标类，默认为false,也就是JDK动态代理，如果为true就启用CGLib代理。  </p><p>看看客户端代码：<br><img src="https://img11.360buyimg.com/img/jfs/t1/79931/10/15163/532818/5dca1e49E10ea9094/b3b1574beb8c64c6.png" alt="image.png"><br>当然，Spring AOP+ASpectj完全实现了注解切面。有兴趣的同学可以去了解一下。</p><h3 id="Spring事务传播7种行为"><a href="#Spring事务传播7种行为" class="headerlink" title="Spring事务传播7种行为"></a>Spring事务传播7种行为</h3><p><img src="https://img12.360buyimg.com/img/jfs/t1/63931/28/15169/753045/5dca6d4cE9b357019/11e7753733558e5a.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 框架学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并发编程_Callable&amp;Future</title>
      <link href="/1024-xy.github.io/2019/11/01/bing-fa-bian-cheng-callable-future-1/"/>
      <url>/1024-xy.github.io/2019/11/01/bing-fa-bian-cheng-callable-future-1/</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程-Callable-amp-Future"><a href="#并发编程-Callable-amp-Future" class="headerlink" title="并发编程_Callable&amp;Future"></a>并发编程_Callable&amp;Future</h1>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并发编程_共享对象</title>
      <link href="/1024-xy.github.io/2019/11/01/bing-fa-bian-cheng-gong-xiang-dui-xiang-1/"/>
      <url>/1024-xy.github.io/2019/11/01/bing-fa-bian-cheng-gong-xiang-dui-xiang-1/</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程-共享对象"><a href="#并发编程-共享对象" class="headerlink" title="并发编程_共享对象"></a>并发编程_共享对象</h1><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>在以下的代码中，主线程和读线程两个线程共同访问变量ready和number。主线程启动读线程，然后把number设置为42，ready赋值为true，读线程一直循环直到发现ready变成true，然后打印出number的值，虽然看上去会输出42，实则不然，很有可能输出0，因为cpu缓存的缘故，甚至线程不会终止，因为缓存永远没有同步机制到内存，所以没能保证主线程写入ready和number对读线程可见。</p><pre><code>public class NoVisibility{    private static boolean ready;    private static int number;    public static class ReaderThread extends Thread{        public void run(){            while(!ready){                Thread.yield();            System.out.println(number);            }        }    }    public static void main(String[] args){        new ReaderThread().start();        number = 42;        ready = true;    }}</code></pre><p>这里甚至可能会出现奇怪的现象，NoVisibility可能会打印0，产生这种情况的原因便是指令发生了<strong>重排序</strong>。</p><h3 id="过期数据"><a href="#过期数据" class="headerlink" title="过期数据"></a>过期数据</h3><p>Novisibility演示了一种没有恰当同步程序，它能股引起意外的后果：过期数据。当线程检查ready变量时，它可能看到一个过期的值。除非每一次访问变量都是同步的，否则很可能得到变量的过期值。更坏的情况，过期既不会发生在全部变量上，也不会完全不出现：一个线程可能会得到一个变量最新的值，但是也可能得到另一个变量先前写入的过期值。<br>&emsp;&emsp;以下代码并不是线程安全的，因为get和set都访问了value域，却没有进行同步。在众多危害中，以下情况对过期数据尤为敏感：如果线程调用了set，而另一个线程此时正在调用get，他可能就看不到更新的数据了。<br>&emsp;&emsp;我们可以通过同步化getter和setter，使以下代码变为线程安全。</p><p><strong>非线程安全的可变整数访问器</strong></p><pre><code>public class MutableInteger{    private int value;    public int get(){        return value;    }    public void set(int value){        this.value = value;    }}</code></pre><p><strong>线程安全的可变整数访问器</strong></p><pre><code>public class SynchronizedInteger{    private int value;    public synchronized int get(){        return value;    }    public synchronized void set(int value){        this.value = value;    }}</code></pre><h3 id="非原子的64位操作"><a href="#非原子的64位操作" class="headerlink" title="非原子的64位操作"></a>非原子的64位操作</h3><p>&emsp;&emsp;当一个线程在没有同步的情况下读取变量，他可能会得到一个过期值。但是至少它可以看到某个线程在那里设定的一个真实数值，而不是一个凭空而来的值。这样的安全保证被称为是最低的安全性。<br>&emsp;&emsp;最低的安全性应用于所有的变量，除了一个例外：没有声明为volatile的64位数值变量（double和long）。java存储模型要求获取和存储操作都为原子的，但是对于非volatile的long和double变量，JVM允许将64位读或写划分为两个32位的操作。如果读和写发生在不同的线程，这种情况读取一个非volatile类型long就可能会出现得到一个值的高32位和另一个值的低32位。因此，即使你并不关心过期数据，但仅仅在多线程程序中使用共享的、可变的long 和 double变量也可能是不安全的，除非将它们声明为volatile类型，或者用锁保护。</p><h3 id="锁和可见性"><a href="#锁和可见性" class="headerlink" title="锁和可见性"></a>锁和可见性</h3><p>&emsp;&emsp;内置锁可以用来确保一个线程以某种可预见的方式看到另一个线程的影响。当A执行执行一个同步块时，线程B也随后进入了同一个锁监视的同步块中，这时就可以保证，在锁释放之前对A可见的变量值，B获得锁之后同样是可见的。换句话说，当B执行到与A相同的锁监视的同步块，A在同步块之中或之前所做的每一件事，对B都是可见的，如果没有同步，就没有这样的保证。<br>&emsp;&emsp;<strong>锁不仅仅是关于同步与互斥的，也是关于内存可见的。为了保证所有线程都能够看到共享的、可变变量的最新值，读取和写入线程必须使用公共的锁同步。</strong></p><h3 id="Volatile变量"><a href="#Volatile变量" class="headerlink" title="Volatile变量"></a>Volatile变量</h3><p>&emsp;&emsp;Java语言也提供了其他的选择，即一种同步的弱形式：volatile变量。它确保对一个变量的更新以可预见的方式告知其他线程。当域声明为volatile类型后，编译器与运行时会监视这个变量：它是共享的，而且对它的操作不会与其他的内存操作一起被重排序。volatile变量不会缓存在寄存器或者缓存在对其他处理器隐藏的地方。读一个volatile类型的变量时，总会返回由某一个线程写入的最新值。<br>&emsp;&emsp;<strong>只有当volatile变量能够简化实现和同步策略的验证时，才使用它们。当验证正确性必须推断可见性问题时，应该避免使用volatile变量。正确使用volatile变量的方式包括：用于确保它们所引用的对象状态的可见性，或者用于标志重要的生命周期事件的发生</strong>  </p><pre><code>volatile boolean sleep;while(sleep){    doSomething();}</code></pre><p>&emsp;&emsp;volatile变量固然方便，但存在限制，比如a++ 这种操作便不是原子化，除非你能保证只有一个线程对变量执行写操作<strong>加锁可以保证原子性，可见性，但volatile只能保证可见性.</strong><br>&emsp;&emsp;只有满足了下面所有标准后，你才能使用volatile变量：</p><ul><li>写入变量并不依赖变量的当前值：或者能确保只有单一线程修改变量的值；</li><li>变量不需要与其他的状态变量共同参与不变约束；</li><li>而且，访问变量时，没有其他的原因需要加锁。<h2 id="发布和逸出"><a href="#发布和逸出" class="headerlink" title="发布和逸出"></a>发布和逸出</h2>发布一个对象的意思是使它能够被当前范围之外的代码所使用。比如将一个引用存储到其他代码可以访问的地方，在一个非私有的方法中返回这个引用，也可以把它传递到其他类的方法中。在很多情况下，我们需要确保对象以及他们的内部状态不被暴露。在另外一些情况下，为了正当的使用目的，我们又的确希望发布一个对象，但是用线程安全的方法完成这些工作时，可能需要同步。如果变量发布内部状态，就可能危及到线程安全。一个对象在尚未准备好时就将它发布，这种情况称为逸出。<h2 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h2>&emsp;&emsp;访问共享的、可变的数据要求要求。一个可以避免同步的方式就是不共享数据。如果数据仅在单线程中访问，就不需要任何同步。线程封闭技术是实现线程安全的最简单方式之一。当对象封闭在一个线程中，这种做法会自动成为线程安全的，即使被封闭的对象本身并不是。<br>&emsp;&emsp;常见的使用线程限制的应用程序是应用池化的JDBC对象。JDBC规范并没有要求Connection对象是线程安全的。然而在典型的的服务器应用中，线程总是从池中获得一个Connection对象，并且用它处理一个单一的请求，最后将它归还。每个线程都会同步处理大多数请求，而且在Connection对象在归还前，池不会再将它分配给其他线程，因此，这种连接管理模式隐式地将Connection对象限制在处于请求处理期间的线程中。  <h3 id="Ad-hoc-线程限制"><a href="#Ad-hoc-线程限制" class="headerlink" title="Ad-hoc 线程限制"></a>Ad-hoc 线程限制</h3>&emsp;&emsp;<strong>Ad-hoc 线程限制</strong>是指维护线程限制性的任务全部落在实现上的这种情况。因为没有可见性修饰符与本地变量等语言特性协助将对象限制在目标线程上，所以这方式是非常容易出错的。事实上，对于像GUI应用中的可视化组件或者数据模型这些线程限制对象，对他们的引用通常是公用域。<h3 id="栈限制"><a href="#栈限制" class="headerlink" title="栈限制"></a>栈限制</h3>&emsp;&emsp;栈限制是线程限制的一种特例，在栈限制中，只能通过本地变量才可以触及对象。正如封装不变约束更容易被保持，本地变量使对象更容易被限制在线程本地中</li></ul><pre><code>public void test(){    int i;    int b;//这些变量都是线程私有的，存储在栈中，别的线程无法访问。}</code></pre><p>维护对象引用的栈限制，需要确保对象没有逸出。倘若我们发布了对象的引用，则该对象便会逸出。</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>&emsp;&emsp;一种维护线程限制的有效方式是使用ThreadLocal，它允许你将每个线程与持有数值的对象关联在一起。ThreadLocal提供了get与set访问器，为每个线程维护一份单独的拷贝。所以get总是返回当前线程执行通过set的最新值。<br>&emsp;&emsp;线程本地变量通常用于防止在基于可变单体或者全局变量的设计之中，出现不正确的共享</p><pre><code>private static ThreadLocal&lt;Connection&gt; connectionHolder = new ThreadLocal&lt;Connection&gt;(){    public Connection initialValue(){        return DriverManager.getConnection(DB_URL);    }}public static Connection getConnection(){    return connectionHolder.ger();}</code></pre><p>&emsp;&emsp;这项技术还用于下面的情况：一个频繁执行的操作既需要像buffer的临时对象，同时还需要每次避免每次重新分配该对象。在5.0以前，Integer.toString()方法使用ThreadLocal存储一个12-byte的缓冲区来格式化结果，而不是使用共享的静态缓冲区，或者在每次调用前都分配一个新的缓冲区。**你可以将ThreadLocal看成一个map&lt;Thread,valeu&gt;但实际他不是，与线程相关的值存储在线程自身对象中，线程终止，这些值会被回收。</p><h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><p>使用final关键字可以使对象变的不可变，不可变对象永远线程安全。只有一下状态一个对象才不可变 </p><ul><li>他的状态创建后不能被修改。</li><li>所有域都是final类型。</li><li>它被正确的创建，没有逸出。<h3 id="final域"><a href="#final域" class="headerlink" title="final域"></a>final域</h3>&emsp;&emsp;final关键字源于C++的const机制，不过受到了很多限制，它对不可变性对象的创建提供了支持。final是不可被修改的（尽管对象的状态可变，这个对象仍然可被修改），final域使得确保初始化安全性成为可能，初始化安全性让不可变性对象不需要同步就能自由的被访问和共享。<h3 id="使用volatile发布不可变对象"><a href="#使用volatile发布不可变对象" class="headerlink" title="使用volatile发布不可变对象"></a>使用volatile发布不可变对象</h3></li></ul><pre><code>private volatile OneValueCache cache = new OneValueCche(null,null);public void service(){    cache = new OneValueCache(i,factors);}</code></pre><h3 id="安全的共享对象"><a href="#安全的共享对象" class="headerlink" title="安全的共享对象"></a>安全的共享对象</h3><p>在并发程序中，遵循使用和共享对象的策略为：</p><ul><li>线程限制：一个线程限制的对象，在通过限制在线程中，而被线程独占，且只能被占有它的线程修改。</li><li>共享只读：一个共享的只读对象，在没有同步的情况下，不会产生线程安全问题，共享只读对象包括可变对象与高效不可变对象。</li><li>共享线程安全：一个线程安全的对象在内部进行同步，所以其他线程无需额外同步，就可以通过公共接口访问它。</li><li>被守护的：一个被守护的对象只能通过特定的锁来访问，被守护的对象包括那些被线程安全对象封装的对象，和一直被特定的锁保护起来的已发布的对象。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并发编程_基础</title>
      <link href="/1024-xy.github.io/2019/11/01/bing-fa-bian-cheng-ji-chu-2/"/>
      <url>/1024-xy.github.io/2019/11/01/bing-fa-bian-cheng-ji-chu-2/</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程基础"><a href="#并发编程基础" class="headerlink" title="并发编程基础"></a>并发编程基础</h1><hr><h2 id="进程与线程的区别与联系"><a href="#进程与线程的区别与联系" class="headerlink" title="进程与线程的区别与联系"></a>进程与线程的区别与联系</h2><p>进程是一个独立运行的程序，它有操作系统分配的内存空间，进程间的切换需要cpu进行空间地址的切换以及物理内存的交互。所以进程间的切换更加消耗资源。而线程是进程的组成基本单位，也是cpu调度的基本单位。</p><h2 id="使用多线程的好处？"><a href="#使用多线程的好处？" class="headerlink" title="使用多线程的好处？"></a>使用多线程的好处？</h2><ol><li>提高程序运行效率：多线程相当于在一个进程中在不同的环境中在同同一时刻共同执行。</li></ol><h2 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h2><h3 id="1、用户线程"><a href="#1、用户线程" class="headerlink" title="1、用户线程"></a>1、用户线程</h3><pre><code> 面试题：在一个进程中一定会有那个进程？ 答：主线程，进程靠主线程进行运行以及创建其他线程进行并行执行。</code></pre><h4 id="1、主线程"><a href="#1、主线程" class="headerlink" title="1、主线程"></a>1、主线程</h4><p>主线程时进程运行必须要有的线程，进程通过它来创建线程以及运行主要逻辑代码，主线程在main方法中运行，main方法运行完毕主线程结束。</p><h4 id="2、子线程"><a href="#2、子线程" class="headerlink" title="2、子线程"></a>2、子线程</h4><p>子线程是由主线程创建出来的线程，它有独立的运行逻辑与主线程互不干涉</p><h4 id="3、GC线程"><a href="#3、GC线程" class="headerlink" title="3、GC线程"></a>3、GC线程</h4><p>GC线程是java程序用于清理jvm内存空间的线程，该线程可以由用户手动调用，也可以由垃圾收集器创建对jvm虚拟机内存进行回收。</p><h3 id="2、守护线程-重点"><a href="#2、守护线程-重点" class="headerlink" title="2、守护线程(重点)"></a>2、守护线程(重点)</h3><h4 id="什么是守护线程（面试题）"><a href="#什么是守护线程（面试题）" class="headerlink" title="什么是守护线程（面试题）"></a>什么是守护线程（面试题）</h4><p>守护线程与主线程息息相关，如果主线程结束，其守护线程也随之死亡(GC线程)。主线程死亡时，gc线程必须死亡，所以gc也是守护线程。<br>实现一个守护线程：我们运行可以发现不管守护线程有没有执行完毕，都随着主线程执行完毕一起销毁  </p><pre><code>public class Thread004 {    public static void main(String[] args) {        Thread thread = new Thread(new Runnable() {            @Override            public void run() {                for(int i = 0; i &lt; 10; i++){                    try {                        Thread.sleep(300);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(&quot;i:&quot; + i);                }            }        });        //将该线程设置为守护线程        thread.setDaemon(true);        thread.start();        for (int i = 0; i &lt; 5; i++) {            try {                Thread.sleep(30);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(&quot;主线程i:&quot; + i);        }        System.out.println(&quot;主线程执行完毕&quot;);    }}</code></pre><h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><h3 id="1、继承Thread类"><a href="#1、继承Thread类" class="headerlink" title="1、继承Thread类"></a>1、继承Thread类</h3><h4 id="Demo1：创建一个继承Thread类的子线程"><a href="#Demo1：创建一个继承Thread类的子线程" class="headerlink" title="Demo1：创建一个继承Thread类的子线程"></a>Demo1：创建一个继承Thread类的子线程</h4><pre><code>```java//继承Thread类.class ThreadDemo01 extends  Thread{    //run方法中写线程需要执行的代码    @Override    public void run() {        for(int i = 0; i &lt; 10 ; i++){            System.out.println(&quot;i:&quot;+i);        }    }}//什么是线程，线程是一条执行路径，每个线程互不影响//什么是多线程，多线程在一个进程中，有多条线程，并行执行。目的是为了提高程序的运行效率。public class Test01 {    public static void main(String[] args) {        //线程的几种分类，用户线程，守护线程        //用户线程：主线程、子线程、GC线程        //创建并启动线程        new ThreadDemo01().start();    }}```</code></pre><h3 id="2、实现Runnable接口（相对于继承方式更推荐这个）"><a href="#2、实现Runnable接口（相对于继承方式更推荐这个）" class="headerlink" title="2、实现Runnable接口（相对于继承方式更推荐这个）"></a>2、实现Runnable接口（相对于继承方式更推荐这个）</h3><p>相对于继承Thread类实现，由于Java只支持单继承，所以并不友好，推荐采用实现接口的方式，这样会有更好的扩展性。  </p><pre><code>class ThreadDemo02 implements Runnable{    @Override    public void run() {        for(int i = 0; i &lt; 10; i++){            System.out.println(&quot;i:&quot;+i);        }    }}public class Thread002 {    public static void main(String[] args) {        Thread thread = new Thread(new ThreadDemo02());        thread.start();    }}</code></pre><h3 id="3、使用匿名内部类"><a href="#3、使用匿名内部类" class="headerlink" title="3、使用匿名内部类"></a>3、使用匿名内部类</h3><p>使用匿名内部类的方式创建一个线程并运行 </p><pre><code>** * 使用内部类的方式创建线程 */public class Thread003 {    public static void main(String[] args) {        new Thread(new Runnable() {            @Override            public void run() {                for(int i = 0; i &lt; 10; i++){                    System.out.println(&quot;i:&quot; + i);                }            }        }).start();    }</code></pre><p>}</p><h3 id="4、使用线程池进行管理（最常用的方式）"><a href="#4、使用线程池进行管理（最常用的方式）" class="headerlink" title="4、使用线程池进行管理（最常用的方式）"></a>4、使用线程池进行管理（最常用的方式）</h3><h2 id="同步与异步的概念"><a href="#同步与异步的概念" class="headerlink" title="同步与异步的概念"></a>同步与异步的概念</h2><hr><p>同步表示代码从上往下进行执行，当一个方法阻塞，线程必须阻塞在那里等待结果的返回。<br>异步表示当一个方法需要等待返回结果，主线程到那里可以创建子线程去进行等待结果，当有结果产生时返回给主线程时，拿到结果执行相应的逻辑。没拿到结果则不需要等待，去进行其他任务。<br>常用的：Http请求分为同步与异步，Ajax的http请求便是异步的。</p><h2 id="多线程运行状态"><a href="#多线程运行状态" class="headerlink" title="多线程运行状态"></a>多线程运行状态</h2><ol><li>新建：new Thread();</li><li>就绪:thread.start();等待cpu分配时间片</li><li>运行:拿到执行权，线程运行</li><li>阻塞：遇到synchronized、wait进行阻塞</li><li>死亡：线程程序执行完毕，线程死亡，判断线程状态是否活着需要使用isAlive方法，如果是运行或者阻塞则返回true<br><img src="https://img-blog.csdnimg.cn/20181120173640764.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70" alt="多线程运行状态"></li></ol><h2 id="join-方法的使用"><a href="#join-方法的使用" class="headerlink" title="join()方法的使用"></a>join()方法的使用</h2><p>join方法的是让其他线程变为等待，t1.join()//让其他线程变为等待，直到当前join方法执行完毕，才进行释放。Thread.join把指定线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了A线程的join()方法，直到A线程执行完毕，才会继续执行线程B  </p><pre><code>/** * join方法的使用示例 */public class Thread005 {    public static void main(String[] args) throws InterruptedException {        Thread t1 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i &lt; 10; i++) {                    try {                        Thread.sleep(200);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(&quot;线程1在执行&quot; + i + &quot;次&quot;);                }            }        });        Thread t2 = new Thread(new Runnable() {            @Override            public void run() {                try {                    t1.join();                } catch (InterruptedException e) {                    e.printStackTrace();                }                for (int i = 0; i &lt; 10; i++) {                    System.out.println(&quot;线程2在执行&quot; + i + &quot;次&quot;);                }            }        });        t1.start();        t2.start();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并发编程_线程安全</title>
      <link href="/1024-xy.github.io/2019/11/01/bing-fa-bian-cheng-java-nei-cun-mo-xing-2/"/>
      <url>/1024-xy.github.io/2019/11/01/bing-fa-bian-cheng-java-nei-cun-mo-xing-2/</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程-线程安全"><a href="#并发编程-线程安全" class="headerlink" title="并发编程_线程安全"></a>并发编程_线程安全</h1><h2 id="什么是线程安全性？"><a href="#什么是线程安全性？" class="headerlink" title="什么是线程安全性？"></a>什么是线程安全性？</h2><p>可以被多个程序调用，并且调用没有共享内存中同一变量的交互，并且不需要使用任何操作来保证线程安全，同时得到的结果跟预期是正确的。那么我们称这个程序线程安全。<br><strong>示例</strong>：<br>线程安全</p><pre><code>public void count(){    int count = 0;    count++;}</code></pre><p>非线程安全</p><pre><code>int count = 0;public void count(){    count++;}</code></pre><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>我们在向无状态的对象中加入一个状态将会破坏他的线程安全如：  </p><pre><code>int count = 0;public void count(){    count++;}</code></pre><p>该count非线程安全，看似count++是个原子操作，其实cpu对它进行了从cpu缓存中读取，+1，写入缓存的操作。假如同时两个线程执行该方法，如果第一个线程在同一个时间拿到这个count并且都看到是9，同时+1写入缓存中，你将不会得到11，而是错误的10。</p><h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h3><p>使用潜在的过期观察值来决策或执行计算，这种竞争条件被称为<strong>检查在运行</strong>，你观察到一些一些事情为真，然后基于你的观察去执行一些动作：但事实上，从你观察再执行的期间，观察结果已经无效，从而引发错误修改。</p><h4 id="惰性初始化竞争条件"><a href="#惰性初始化竞争条件" class="headerlink" title="惰性初始化竞争条件"></a>惰性初始化竞争条件</h4><p>懒汉式单例模式就是一个很明显的例子(<strong>Dont do this</strong>)：</p><pre><code>public class LazyInitRace{    private ExpensiveObject instance = null;    public ExpensiveObject getInstance(){        if(instance == null){            instance = new ExpensiveObject();        }        return instance;    }}</code></pre><h3 id="复合操作"><a href="#复合操作" class="headerlink" title="复合操作"></a>复合操作</h3><p>前面说到的懒汉式单例以及count++都是非线程安全的，如何解决线程安全呢？为了避免竞争条件，必须阻止其他线程访问我们正在修改的变量，让我们可以确保：其他的线程想要查看和修改这一状态时，必须在我们线程开始之前或者之后。我们可以使用线程安全类来实现count++的安全问题。</p><pre><code>private final AtomicLong count = new AtomicLong (0);public void count(){    //对count进行自增操作    count.incrementAndGet();}</code></pre><p>java.util.concurrent.atomic包中包括了原子变量类，而这些对数值的操作都可以看做是原子操作。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>通过线程安全的对象来管理类中非安全的状态，可以维护线程的安全性，但这样我们只能加入一种状态，但我们想要加入更多状态，可以仅仅加入更多线程安全的变量吗？</p><pre><code>private final AtomicReference&lt;Integer&gt; lastNumber = new AtomicReference&lt;Integer&gt;();private final AtomicReference&lt;Integer&gt; lastFactor = new AtomicReference&lt;Integer&gt;();public void service(){    Integer i = exec();    //存在竞争条件，不安全    Integer[] factorys  = factory[i]     lastNumber.set(i);    lastFactory.set(factors);}</code></pre><p>当A线程尝试获取这两个变量时，B线程已经修改了他们，A拿到了错误的结果，所以线程不安全。为了保护状态的一致性，要在单一的原子操作中更新相互关联的状态变量。  </p><h3 id="内部锁"><a href="#内部锁" class="headerlink" title="内部锁"></a>内部锁</h3><p>java提供了强制原子性的内置锁机制：synchronized块。一个synchronized块有两个部分：锁对象的引用，以及这个锁保护的代码块。其中<a href="https://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">synchronized底层原理</a>为我们详细解释了这一关键字具体在字节码级别的实现。synchronized在方法上，拿到的对象就是对象本身，如果在静态方法上，则拿到该类的class字节码对象。每个java对象都可以隐式的扮演一个用于同步的锁的角色：这些内置的锁被称为内部锁或者监视器锁。执行线程进入synchronized块之前会自动获得锁；而无论正常退出还是抛出异常，线程都将释放锁资源。内部锁是互斥锁。</p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>当一个线程请求其他线程已经占有的锁时，请求线程将会被阻塞。然而内部锁是可重进入的，因此线程在试图获得它自己占有的锁时，请求会成功。重入的实现是为每个锁关联一个请求计数和一个占有它的线程。当计数器为0时，认为锁未被占用。线程请求一个未被占用的锁时，jvm将记录锁的占有者，并将请求数设置为1.如果同一线程在此请求这个锁，计数将递增；每次占用线程退出同步块，将递减。直到0时，锁释放。</p><h2 id="用锁来保护状态"><a href="#用锁来保护状态" class="headerlink" title="用锁来保护状态"></a>用锁来保护状态</h2><p>对于每个可被多个线程访问的可变状态变量，如果所有访问它的线程在执行时，都占有同一个锁，我们便称它是由锁保护的。</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并发编程_构建块</title>
      <link href="/1024-xy.github.io/2019/11/01/bing-fa-bian-cheng-gou-jian-kuai-1/"/>
      <url>/1024-xy.github.io/2019/11/01/bing-fa-bian-cheng-gou-jian-kuai-1/</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程-构建块"><a href="#并发编程-构建块" class="headerlink" title="并发编程_构建块"></a>并发编程_构建块</h1><h2 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h2><p>同步容器分为两部分，一个是vector和HashTable。他们早期是JDK的一部分：另一个是他们的同系容器，在JDK1.2才被加入的同步包装类。这些类是由Collections.synchronizedxxx工厂方法创建的。这些类通过封装他们的状态，并对每一个公共的方法进行同步而实现了线程安全。</p><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>并发容器是为多线程而设计的，其中有代替Map的ConcurrentHashMap;读多写少的CopyOnWriteArrayList。同样新增了Queue和BlockingQueue。Queue用来临时保存正在等待被进一步处理的一系列元素。JDK提供了几种实现，包括一个传统的FIFO队列，ConcurrnetLinkedQueue;一个具有优先级的队列，PriorityQueue。BlockingQueue扩展了Queue，增加了可阻塞的插入和获取的操作。如果队列是空的，一个获取操作会阻塞到直到队列中存在元素；如果队列是满的，会阻塞到存在空间。阻塞队列对于生产者和消费者的设计非常有用。</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap与其他容器一起，提供了不会抛出ConcurrentModificationException的迭代器，因此不需要再容器中加锁。但是对于整个Map进行操作的方法如size()和isEmpty,他们的语义在反映容器并发特性上被轻微的弱化了。因为size()的结果对于计算的时候可能已经过期，它仅仅是一个估算值。concurrentHashMap使用的是分离锁。</p><h3 id="对比ConcurrentHashMap与HashMap"><a href="#对比ConcurrentHashMap与HashMap" class="headerlink" title="对比ConcurrentHashMap与HashMap"></a>对比ConcurrentHashMap与HashMap</h3><h4 id="1、HashMap"><a href="#1、HashMap" class="headerlink" title="1、HashMap"></a>1、HashMap</h4><p>hashmap分为1.7与1.8两个版本其中1.7的版本如下图所示：<br><img src="https://i.loli.net/2019/05/08/5cd1d2be77958.jpg" alt="hashmap1.7结构图"><br>看看其实现<br><img src="https://i.loli.net/2019/05/08/5cd1d2bfd6aba.jpg" alt="hashmap实现">  </p><ul><li>初始化桶大小</li><li>桶最大值</li><li>默认负载因子</li><li>table真正存放数据的数组</li><li>Map存放数量的大小</li><li>桶大小</li><li>负载因子，可在初始化时显示指定  </li></ul><p>而在1.8的版本中增加了当链表达到8的长度时会转化为红黑树，而Entry改成了Node。在put方法中会判断结构是否是红黑树，如果是红黑树则按照红黑树的规则插入数据，判断是否大于阈值，大于则转为红黑树。</p><p>但是HashMap同样存在并发问题</p><pre><code>final HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();for (int i = 0; i &lt; 1000; i++) {    new Thread(new Runnable() {        @Override        public void run() {            map.put(UUID.randomUUID().toString(), &quot;&quot;);        }    }).start();}</code></pre><p>HashMap 扩容的时候会调用 resize() 方法，就是这里的并发操作容易在一个桶上形成环形链表；这样当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就会出现死循环。</p><h4 id="ConcurrentHashMap-1"><a href="#ConcurrentHashMap-1" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>1.7版本结构图：  </p><p><img src="https://i.loli.net/2019/05/08/5cd1d2c5ce95c.jpg" alt="ConcurrentHashMap结构图"><br>如图所示，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。<br>它的核心成员变量：</p><pre><code>/** * Segment 数组，存放数据时首先需要定位到具体的 Segment 中。 */final Segment&lt;K,V&gt;[] segments;transient Set&lt;K&gt; keySet;transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</code></pre><p>Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下：</p><pre><code> static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {       private static final long serialVersionUID = 2249069246763182397L;       // 和 HashMap 中的 HashEntry 作用一样，真正存放数据的桶       transient volatile HashEntry&lt;K,V&gt;[] table;       transient int count;       transient int modCount;       transient int threshold;       final float loadFactor;}</code></pre><p>看看其中 HashEntry 的组成：<br><img src="https://i.loli.net/2019/05/08/5cd1d2c635c69.jpg" alt="HashEntry"><br>和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。</p><p>原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。  </p><p>下面也来看看核心的 put get 方法。<br>put 方法</p><pre><code>public V put(K key, V value) {    Segment&lt;K,V&gt; s;    if (value == null)        throw new NullPointerException();    int hash = hash(key);    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment        s = ensureSegment(j);    return s.put(key, hash, value, false);}</code></pre><p>首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put。  </p><pre><code>final V put(K key, int hash, V value, boolean onlyIfAbsent) {    HashEntry&lt;K,V&gt; node = tryLock() ? null :        scanAndLockForPut(key, hash, value);    V oldValue;    try {        HashEntry&lt;K,V&gt;[] tab = table;        int index = (tab.length - 1) &amp; hash;        HashEntry&lt;K,V&gt; first = entryAt(tab, index);        for (HashEntry&lt;K,V&gt; e = first;;) {            if (e != null) {                K k;                if ((k = e.key) == key ||                    (e.hash == hash &amp;&amp; key.equals(k))) {                    oldValue = e.value;                    if (!onlyIfAbsent) {                        e.value = value;                        ++modCount;                    }                    break;                }                e = e.next;            }            else {                if (node != null)                    node.setNext(first);                else                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);                int c = count + 1;                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)                    rehash(node);                else                    setEntryAt(tab, index, node);                ++modCount;                count = c;                oldValue = null;                break;            }        }    } finally {        unlock();    }    return oldValue;}</code></pre><p>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理。</p><p>首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁。  </p><p>在1.8版本中，则使用了synchronized+cas算法来进行锁的获取  </p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并发编程_线程池原理</title>
      <link href="/1024-xy.github.io/2019/11/01/bing-fa-bian-cheng-xian-cheng-chi-yuan-li-1/"/>
      <url>/1024-xy.github.io/2019/11/01/bing-fa-bian-cheng-xian-cheng-chi-yuan-li-1/</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程-线程池原理"><a href="#并发编程-线程池原理" class="headerlink" title="并发编程_线程池原理"></a>并发编程_线程池原理</h1><h2 id="阻塞队列与非阻塞队列"><a href="#阻塞队列与非阻塞队列" class="headerlink" title="阻塞队列与非阻塞队列"></a>阻塞队列与非阻塞队列</h2><ul><li>阻塞队列进行出队与入队操作会进行等待。</li><li>非阻塞队列不会进行阻塞<h3 id="ConcurrentLinkedQueue-非阻塞"><a href="#ConcurrentLinkedQueue-非阻塞" class="headerlink" title="ConcurrentLinkedQueue(非阻塞)"></a>ConcurrentLinkedQueue(非阻塞)</h3><h3 id="BlockingQueue-阻塞"><a href="#BlockingQueue-阻塞" class="headerlink" title="BlockingQueue(阻塞)"></a>BlockingQueue(阻塞)</h3>实现BlockingQueue接口的有ArrayBlockingQueue, DelayQueue, LinkedBlockingDeque, LinkedBlockingQueue, LinkedTransferQueue, PriorityBlockingQueue, SynchronousQueue，而这几种常见的阻塞队列也是在实际编程中会常用的，下面对这几种常见的阻塞队列进行说明：<blockquote><p>1.ArrayBlockingQueue  </p></blockquote></li></ul><p>ArrayBlockingQueue是由数组实现的有界阻塞队列。该队列命令元素FIFO（先进先出）。因此，对头元素时队列中存在时间最长的数据元素，而对尾数据则是当前队列最新的数据元素。ArrayBlockingQueue可作为“有界数据缓冲区”，生产者插入数据到队列容器中，并由消费者提取。ArrayBlockingQueue一旦创建，容量不能改变。<br>当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p><blockquote><p>2.LinkedBlockingQueue</p></blockquote><p>LinkedBlockingQueue是用链表实现的有界阻塞队列，同样满足FIFO的特性，与ArrayBlockingQueue相比起来具有更高的吞吐量，为了防止LinkedBlockingQueue容量迅速增，损耗大量内存。通常在创建LinkedBlockingQueue对象时，会指定其大小，如果未指定，容量等于Integer.MAX_VALUE</p><blockquote><p>3.PriorityBlockingQueue</p></blockquote><p>PriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现compareTo()方法来指定元素排序规则，或者初始化时通过构造器参数Comparator来指定排序规则。</p><blockquote><p>4.SynchronousQueue</p></blockquote><p>SynchronousQueue每个插入操作必须等待另一个线程进行相应的删除操作，因此，SynchronousQueue实际上没有存储任何数据元素，因为只有线程在删除数据时，其他线程才能插入数据，同样的，如果当前有线程在插入数据时，线程才能删除数据。SynchronousQueue也可以通过构造器参数来为其指定公平性。</p><blockquote><p>5.LinkedTransferQueue</p></blockquote><p>LinkedTransferQueue是一个由链表数据结构构成的无界阻塞队列，由于该队列实现了TransferQueue接口，与其他阻塞队列相比主要有以下不同的方法：<br>transfer(E e)<br>如果当前有线程（消费者）正在调用take()方法或者可延时的poll()方法进行消费数据时，生产者线程可以调用transfer方法将数据传递给消费者线程。如果当前没有消费者线程的话，生产者线程就会将数据插入到队尾，直到有消费者能够进行消费才能退出；<br>tryTransfer(E e)<br>tryTransfer方法如果当前有消费者线程（调用take方法或者具有超时特性的poll方法）正在消费数据的话，该方法可以将数据立即传送给消费者线程，如果当前没有消费者线程消费数据的话，就立即返回false。因此，与transfer方法相比，transfer方法是必须等到有消费者线程消费数据时，生产者线程才能够返回。而tryTransfer方法能够立即返回结果退出。<br>tryTransfer(E e,long timeout,imeUnit unit)<br>与transfer基本功能一样，只是增加了超时特性，如果数据才规定的超时时间内没有消费者进行消费的话，就返回false。</p><h3 id="基于BlockingQueue的生产者消费者模式"><a href="#基于BlockingQueue的生产者消费者模式" class="headerlink" title="基于BlockingQueue的生产者消费者模式"></a>基于BlockingQueue的生产者消费者模式</h3><pre><code>package com.xxy.blockingqueue;import java.util.concurrent.BlockingQueue;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.TimeUnit;import java.util.concurrent.atomic.AtomicInteger;class Producer implements Runnable{    private BlockingQueue blockingQueue;    private AtomicInteger count = new AtomicInteger(0    );    private volatile  boolean flag = true            ;    Producer(BlockingQueue blockingQueue){        this.blockingQueue = blockingQueue;    }    public  void stop(){        this.flag = false;    }    @Override    public void run() {        System.out.println(&quot;生产者线程已经启动&quot;);        try {            while (flag){                String data = count.incrementAndGet() + &quot;&quot;;                boolean result = blockingQueue.offer(data,2, TimeUnit.SECONDS);                if(result){                    System.out.println(&quot;生产者存入队列成功&quot; + data);                }else {                    System.out.println(&quot;生产者存入队列失败&quot; + data);                }                Thread.sleep(1000);            }        } catch (InterruptedException e) {            e.printStackTrace();        }finally {            System.out.println(&quot;生产者线程结束&quot;);        }    }}class Consumer implements Runnable{    private BlockingQueue blockingQueue;    private volatile  boolean flag = true;    Consumer(BlockingQueue blockingQueue){        this.blockingQueue = blockingQueue;    }    @Override    public void run() {        System.out.println(&quot;消费者线程已经启动&quot;);        try {            while (flag){                String data = (String) blockingQueue.poll(2,TimeUnit.SECONDS);                if(data == null){                    System.out.println(&quot;消费超过2秒时间，没有获取到队列信息&quot;);                    flag = false;                    return;                }                System.out.println(&quot;消费者获取到data:&quot; + data);            }        }catch (Exception e){        }finally {            System.out.println(&quot;消费者线程结束&quot;);        }    }}public class Test004 {    public static void main(String[] args) throws InterruptedException {        BlockingQueue blockingQueue = new LinkedBlockingQueue(10);        Producer producer = new Producer(blockingQueue);        Consumer consumer = new Consumer(blockingQueue);        Thread t1 = new Thread(producer);        Thread t2 = new Thread(consumer);        t1.start();        t2.start();        Thread.sleep(1000 * 10);        producer.stop();    }}</code></pre><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>java线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行的任务的程序，都可以使用线程池。在开发过程中，需要合理的使用线程池。</p><h3 id="线程池作用"><a href="#线程池作用" class="headerlink" title="线程池作用"></a>线程池作用</h3><ul><li>降低资源消耗：通过重复利用已创建的线程来降低线程创建和线程销毁造成的消耗。</li><li>提高效率：当任务到达，不必等到线程创建就能立即执行</li><li>方便管理：使用线程池，可以做到统一的调优和监控<h3 id="如何合理的配置线程池线程数？"><a href="#如何合理的配置线程池线程数？" class="headerlink" title="如何合理的配置线程池线程数？"></a>如何合理的配置线程池线程数？</h3>最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目<br>高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？<br>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换<br>（2）并发不高、任务执行时间长的业务要区分开看：<br>　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以适当加大线程池中的线程数目，让CPU处理更多的业务<br>　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换<br>（3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。<br>最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。  <h3 id="线程池的四种创建方式"><a href="#线程池的四种创建方式" class="headerlink" title="线程池的四种创建方式"></a>线程池的四种创建方式</h3>java通过Executor提供四种线程池：  </li><li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，灵活回收空闲线程，若无可回收，则新建线程。  </li><li>newFixThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。  </li><li>newScheduledThreadPool创建一个定长线程池，支持周期性任务执行。<br>newSingleThreadPool创建一个单线程化的线程池，它只会用唯一工作的工作线程来执行任务，按照顺序执行。</li></ul><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><pre><code> /**     * Creates a new {@code ThreadPoolExecutor} with the given initial     * parameters and default thread factory and rejected execution handler.     * It may be more convenient to use one of the {@link Executors} factory     * methods instead of this general purpose constructor.     *     * @param corePoolSize the number of threads to keep in the pool, even     *        if they are idle, unless {@code allowCoreThreadTimeOut} is set     * @param maximumPoolSize the maximum number of threads to allow in the     *        pool     * @param keepAliveTime when the number of threads is greater than     *        the core, this is the maximum time that excess idle threads     *        will wait for new tasks before terminating.     * @param unit the time unit for the {@code keepAliveTime} argument     * @param workQueue the queue to use for holding tasks before they are     *        executed.  This queue will hold only the {@code Runnable}     *        tasks submitted by the {@code execute} method.     * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;     *         {@code corePoolSize &lt; 0}&lt;br&gt;     *         {@code keepAliveTime &lt; 0}&lt;br&gt;     *         {@code maximumPoolSize &lt;= 0}&lt;br&gt;     *         {@code maximumPoolSize &lt; corePoolSize}     * @throws NullPointerException if {@code workQueue} is null     */    public ThreadPoolExecutor(int corePoolSize,//核心线程数                              int maximumPoolSize,//最大线程数                              long keepAliveTime,//保持存活时间                              TimeUnit unit,//存放队列超时时间                              BlockingQueue&lt;Runnable&gt; workQueue) {//工作线程队列        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,             Executors.defaultThreadFactory(), defaultHandler);    }</code></pre><p><strong>步骤：</strong></p><ol><li>用户提交给线程池</li><li>判断是否大于核心线程数</li><li>如果大于核心线程数判断缓存队列是否已满，没满则存入队列，如果小于核心线程数，则创建线程执行任务。<br>具体原理如下：<br><img src="https://i.loli.net/2019/10/28/5v3zinyGOZ1hwrd.png" alt="线程池原理.png"></li></ol><p><strong>核心线程数与最大核心线程数的区别：</strong><br>核心线程数表示最大运行线程数，最大线程数表示最多可以创建多少个线程。<br>核心线程数只能小于等于最大线程数</p>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并发编程_线程之间的通讯</title>
      <link href="/1024-xy.github.io/2019/11/01/bing-fa-bian-cheng-xian-cheng-zhi-jian-de-tong-xun-1/"/>
      <url>/1024-xy.github.io/2019/11/01/bing-fa-bian-cheng-xian-cheng-zhi-jian-de-tong-xun-1/</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程-线程之间的通讯"><a href="#并发编程-线程之间的通讯" class="headerlink" title="并发编程_线程之间的通讯"></a>并发编程_线程之间的通讯</h1><h2 id="volatile与Synchronized的区别"><a href="#volatile与Synchronized的区别" class="headerlink" title="volatile与Synchronized的区别"></a>volatile与Synchronized的区别</h2><ul><li>volatile只能保持可见性，但不能保证原子性，synchronized既可以保证可见性又可以保证原子性</li><li>volatile禁止重排序，synchronized不禁止重排序。</li><li>volatile不需要加锁，比synchronized更加轻量级，并且不会阻塞线程。</li><li>volatile是变量修饰符，而synchronized是方法或者块的修饰符</li></ul><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>编译器会对没有依赖关系的代码进行重排序<br>以下代码可能会发生重排序。</p><pre><code>int a;int b;</code></pre><h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>不管怎么去做重排序，其目的都是为了提高代码执行效率，但是不能影响正常结果。重排序只会在多线程的情况下预见，单线程不会。</p><pre><code>class RecordExample{    int a = 0;    boolean flag = false;    public void writer(){        a = 1;//1        flag = true;//2    }    public void reader(){        if(flag){//3            int i = a * a;//4        }    }}</code></pre><p>假如在writer()方法中发生了重排序，将使得reader得到错误的结果，此时flag=true;a还是0。</p><h2 id="wait和notify以及对象锁池"><a href="#wait和notify以及对象锁池" class="headerlink" title="wait和notify以及对象锁池"></a>wait和notify以及对象锁池</h2><h3 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h3><pre><code>/** * 生产者和消费者，wait()和notify()的实现 * @author ZGJ * @date 2017年6月22日 */public class Test1 {    private static Integer count = 0;    private static final Integer FULL = 10;    private static String LOCK = &quot;lock&quot;;    public static void main(String[] args) {        Test1 test1 = new Test1();        new Thread(test1.new Producer()).start();        new Thread(test1.new Consumer()).start();        new Thread(test1.new Producer()).start();        new Thread(test1.new Consumer()).start();        new Thread(test1.new Producer()).start();        new Thread(test1.new Consumer()).start();        new Thread(test1.new Producer()).start();        new Thread(test1.new Consumer()).start();    }    class Producer implements Runnable {        @Override        public void run() {            for (int i = 0; i &lt; 10; i++) {                try {                    Thread.sleep(3000);                } catch (Exception e) {                    e.printStackTrace();                }                synchronized (LOCK) {                    while (count == FULL) {                        try {                            LOCK.wait();                        } catch (Exception e) {                            e.printStackTrace();                        }                    }                    count++;                    System.out.println(Thread.currentThread().getName() + &quot;生产者生产，目前总共有&quot; + count);                    LOCK.notifyAll();                }            }        }    }    class Consumer implements Runnable {        @Override        public void run() {            for (int i = 0; i &lt; 10; i++) {                try {                    Thread.sleep(3000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                synchronized (LOCK) {                    while (count == 0) {                        try {                            LOCK.wait();                        } catch (Exception e) {                        }                    }                    count--;                    System.out.println(Thread.currentThread().getName() + &quot;消费者消费，目前总共有&quot; + count);                    LOCK.notifyAll();                }            }        }    }}</code></pre><h3 id="wait与notify"><a href="#wait与notify" class="headerlink" title="wait与notify"></a>wait与notify</h3><p>1、为什么wait与notify需要定义在object中呢？<br>其实原理很简单，我们需要知道在java对象中，对象头里面含有锁标志，每个对象同时在虚拟机中对应一个监视器，但线程拿到该对象的锁标志，监视器会监视该线程的锁情况，所以在java中是用对象进行加锁，而所有对象又继承于Object类，所以这样定义在Object中，所有对象才会有唤醒和等待的方法。</p><h3 id="对象锁池"><a href="#对象锁池" class="headerlink" title="对象锁池"></a>对象锁池</h3><p>在Java中，每个对象都有两个池，锁(monitor)池和等待池  </p><ul><li>锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。</li><li>等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁(因为wait()方法必须出现在synchronized中，这样自然在执行wait()方法之前线程A就已经拥有了该对象的锁)，同时线程A就进入到了该对象的等待池中。如果另外的一个线程调用了相同对象的notifyAll()方法，那么处于该对象的等待池中的线程就会全部进入该对象的锁池中，准备争夺锁的拥有权。如果另外的一个线程调用了相同对象的notify()方法，那么仅仅有一个处于该对象的等待池中的线程(随机)会进入该对象的锁池.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
